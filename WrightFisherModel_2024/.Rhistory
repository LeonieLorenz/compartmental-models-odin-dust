adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
plot(det_mcmc1)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_GenerationTest.R")
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
#vacc_time <- 0
#dt <- 1/36
migVec <- avg_cluster_freq
as_double_mtx <- function(x){
sapply(x,as.double)
}
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = lapply(intermed_gene_presence_absence_consensus[-1,-1],as_double_mtx), capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
transform <- function(complex_data) {
mcstate_transform <- function(mcstate_params) {
odin_dust_params <- c(complex_data, as.list(mcstate_params))
odin_dust_params
}
mcstate_transform
}
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
transformed_params <<- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_GenerationTest.R")
# likelihood for fitting:
ll_pois <<- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
#data_size <- sum(unlist(observed))
data_size <- sum(unlist(observed[as.character(1:(nrow(state)-1))]))
#model_size = sum(unlist(state))
model_size = sum(unlist(state[-1, , drop = TRUE]))
exp_noise <- 1e6
for (i in 1:(nrow(state)-1)){
if (is.na(observed[[as.character(i)]])) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length( state[1+i, , drop = TRUE]/model_size * data_size))
} else {
lambda <-  state[1+i, , drop = TRUE]/model_size * data_size + rexp(n = length( state[1+i, , drop = TRUE]/model_size * data_size), rate = exp_noise)
ll_obs <- dpois(x = observed[[as.character(i)]], lambda = lambda, log = TRUE)
}
result <- result + ll_obs
}
result
}
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
#vacc_time <- 0
#dt <- 1/36
migVec <- avg_cluster_freq
as_double_mtx <- function(x){
sapply(x,as.double)
}
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = lapply(intermed_gene_presence_absence_consensus[-1,-1],as_double_mtx), capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
transform <- function(complex_data) {
mcstate_transform <- function(mcstate_params) {
odin_dust_params <- c(complex_data, as.list(mcstate_params))
odin_dust_params
}
mcstate_transform
}
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
transformed_params <<- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_GenerationTest.R")
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
#vacc_time <- 0
#dt <- 1/36
migVec <- avg_cluster_freq
as_double_mtx <- function(x){
sapply(x,as.double)
}
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = lapply(intermed_gene_presence_absence_consensus[-1,-1],as_double_mtx), capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
transform <- function(complex_data) {
mcstate_transform <- function(mcstate_params) {
odin_dust_params <- c(complex_data, as.list(mcstate_params))
odin_dust_params
}
mcstate_transform
}
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
transformed_params <<- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_GenerationTest.R")
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
#vacc_time <- 0
#dt <- 1/36
migVec <- avg_cluster_freq
as_double_mtx <- function(x){
sapply(x,as.double)
}
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = lapply(intermed_gene_presence_absence_consensus[-1,-1],as_double_mtx), capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
transform <- function(complex_data) {
mcstate_transform <- function(mcstate_params) {
odin_dust_params <- c(complex_data, as.list(mcstate_params))
odin_dust_params
}
mcstate_transform
}
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
transformed_params <<- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
exp(-6.2045853)
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
(1+0.2)^0.2
(1+0.2)^0.3
1.037137 + 1.05622
(1+0.2)^0.3 * (1-0.3)
1.037137 + 0.739354
1.037137 / 2.093357
1.037137 / 1.776491
1.05622 / 2.093357
0.739354 / 1.776491
0.73/1.056
0.416/0.5
(1+0.2)^(-0.2)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_GenerationTest.R")
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
#vacc_time <- 0
#dt <- 1/36
migVec <- avg_cluster_freq
as_double_mtx <- function(x){
sapply(x,as.double)
}
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = lapply(intermed_gene_presence_absence_consensus[-1,-1],as_double_mtx), capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, migVec = migVec, sigma_w = pmcmc_sigma_w)
transform <- function(complex_data) {
mcstate_transform <- function(mcstate_params) {
odin_dust_params <- c(complex_data, as.list(mcstate_params))
odin_dust_params
}
mcstate_transform
}
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
transformed_params <<- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
