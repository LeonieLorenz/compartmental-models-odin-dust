n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WFmodel$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WFmodel$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
combined_compare(x[,1,37],mass_cluster_freq_2) + combined_compare(x[,1,73],mass_cluster_freq_3)
}
PopPUNK_clusters <- readRDS("PopPUNK_clusters.rds")
PP_intermed_gene_presence_absence_consensus <- readRDS(file = "PP_intermed_gene_presence_absence_consensus.rds")
PP_intermed_gene_presence_absence_consensus_matrix <- sapply(PP_intermed_gene_presence_absence_consensus[-1,-1],as.double)
PP_model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
#delta_ranking <- readRDS(file = "delta_ranking.rds")
PP_mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
PP_mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
PP_mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
PP_mass_VT <- readRDS(file = "PP_mass_VT.rds")
PP_mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
PP_avg_cluster_freq <- rep(1/PP_mass_clusters, PP_mass_clusters)
WF_PP <- odin.dust::odin_dust("NFDS_Model.R")
PP_fit_dfoptim <- function(params){
all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(PP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = PP_intermed_gene_presence_absence_consensus_matrix, sigma_f = params[1], sigma_w = params[2], prop_f = params[3], delta = delta_ranking, m = params[4], migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = params[5], vacc_time = 0)
WFmodel <- WF_PP$new(pars = all_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WFmodel$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WFmodel$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
combined_compare(x[,1,37],PP_mass_cluster_freq_2) + combined_compare(x[,1,73],PP_mass_cluster_freq_3)
}
Mass_Samples_accCodes <- readRDS(file = "Mass_Samples_accCodes.rds")
ggC_intermed_gene_presence_absence_consensus <- readRDS(file = "ggC_intermed_gene_presence_absence_consensus.rds")
ggC_intermed_gene_presence_absence_consensus_matrix <- sapply(ggC_intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "model_start_pop.rds")
ggC_delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "mass_VT.rds")
WF_ggC <- odin.dust::odin_dust("NFDS_Model.R")
# copy of WrightFisherModel/WrightFisher_newData_nGenotypes_haploid_PopsizeVariablePois.R
mass_clusters <- length(unique(Mass_Samples_accCodes$SequenceCluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
params_ggC <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(ggC_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = ggC_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.2193191513, sigma_w = 0.0007111157, prop_f = 0.3735531590, delta = ggC_delta_ranking, m = 0.0052207254, migVec = avg_cluster_freq, vaccTypes = mass_VT, v = 0.1321567425, vacc_time = 0)
ggC_WFmodel <- WF_ggC$new(pars = params_ggC,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
ggC_fit_dfoptim <- function(params){
all_params <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(ggC_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = ggC_intermed_gene_presence_absence_consensus_matrix, sigma_f = params[1], sigma_w = params[2], prop_f = params[3], delta = ggC_delta_ranking, m = params[4], migVec = avg_cluster_freq, vaccTypes = mass_VT, v = params[5], vacc_time = 0)
WFmodel <- WF_ggC$new(pars = all_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WFmodel$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WFmodel$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
combined_compare(x[,1,37],mass_cluster_freq_2) + combined_compare(x[,1,73],mass_cluster_freq_3)
}
PopPUNK_clusters <- readRDS("PopPUNK_clusters.rds")
ggCPP_intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
ggCPP_intermed_gene_presence_absence_consensus_matrix <- sapply(ggCPP_intermed_gene_presence_absence_consensus[-1,-1],as.double)
PP_model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
ggC_delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
PP_mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
PP_mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
PP_mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
PP_mass_VT <- readRDS(file = "PP_mass_VT.rds")
PP_mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
PP_avg_cluster_freq <- rep(1/PP_mass_clusters, PP_mass_clusters)
ggCPP_fit_dfoptim <- function(params){
all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = params[1], sigma_w = params[2], prop_f = params[3], delta = ggC_delta_ranking, m = params[4], migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = params[5], vacc_time = 0)
WFmodel <- WF_ggC$new(pars = all_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WFmodel$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WFmodel$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
combined_compare(x[,1,37],PP_mass_cluster_freq_2) + combined_compare(x[,1,73],PP_mass_cluster_freq_3)
}
source("CreateLollipopPlot.R")
dim(ggC_intermed_gene_presence_absence_consensus)
nrow(ggC_intermed_gene_presence_absence_consensus)
nrow(ggC_intermed_gene_presence_absence_consensus)-1
rbinom(nrow(ggC_intermed_gene_presence_absence_consensus)-1,1,0.3)
rbinom(nrow(ggC_intermed_gene_presence_absence_consensus)-1,1,0.3)
nrow(ggC_intermed_gene_presence_absence_consensus)-1/10
(nrow(ggC_intermed_gene_presence_absence_consensus)-1)/10
(nrow(ggC_intermed_gene_presence_absence_consensus)-1)/6
(nrow(ggC_intermed_gene_presence_absence_consensus)-1)/8
(nrow(ggC_intermed_gene_presence_absence_consensus)-1)/12
(nrow(ggC_intermed_gene_presence_absence_consensus)-1)/14
(nrow(ggC_intermed_gene_presence_absence_consensus)-1)/2
887/9
887/17
887/19
887/3
WF_findGenes <- odin.dust::odin_dust("NFDS_Model_FindGenes.R")
WF_findGenes <- odin.dust::odin_dust("NFDS_Model_FindGenes.R")
WF_findGenes <- odin.dust::odin_dust("NFDS_Model_FindGenes.R")
# create a vector with randomly distributed zeros and ones of the length of the number of genes and the number of ones determined by prop_f
nfds_gene_bool <- rbinom(nrow(ggC_intermed_gene_presence_absence_consensus)-1,1,0.3)
all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3, delta = nfds_gene_bool, m = 0.005, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.05, vacc_time = 0)
WFmodel_findGenes <- WF_findGenes$new(pars = all_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3, delta_bool = nfds_gene_bool, m = 0.005, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.05, vacc_time = 0)
WFmodel_findGenes <- WF_findGenes$new(pars = all_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
PopPUNK_clusters <- readRDS("PopPUNK_clusters.rds")
ggCPP_intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
ggCPP_intermed_gene_presence_absence_consensus_matrix <- sapply(ggCPP_intermed_gene_presence_absence_consensus[-1,-1],as.double)
all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3, delta_bool = as.double(nfds_gene_bool), m = 0.005, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.05, vacc_time = 0)
WFmodel_findGenes <- WF_findGenes$new(pars = all_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
WFmodel_findGenes$run(10)
1775/25
find_genes_df <- data.frame(matrix(0,nrow = nrow(ggC_intermed_gene_presence_absence_consensus)-1, ncol = 50))
rep(c(rep(0,70),1),25)
length(rep(c(rep(0,70),1),25))
length(rep(c(rep(0,70),1),25)[1:1774])
rep(0,0)
length(rep(c(rep(0,70),1),27)[1:1774])
for (i in 1:25) {
find_genes_df[,i] <- rep(c(1,rep(0,70)),30)[i:(1773 + i)]
}
View(find_genes_df)
rep(c(1,rep(0,70)),30)[2:(1773 + 2)]
sum(rep(c(1,rep(0,70)),30)[2:(1773 + 2)])
1775/25
find_genes_df <- data.frame(matrix(0,nrow = nrow(ggC_intermed_gene_presence_absence_consensus)-1, ncol = 50))
for (i in 1:25) {
find_genes_df[,i] <- rep(c(1,rep(0,24)),75)[i:(1773 + i)]
}
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),75)[i:(1773 + i)]
}
rep(c(rep(0,24),1),75)[1:(1773 + 1)]
View(find_genes_df)
sum(rep(c(rep(0,24),1),75)[1:(1773 + 1)])
c(rep(0,1774),rep(1,71),rep(0,71))[1:1774]
sum(c(rep(0,1774),rep(1,71),rep(0,71))[1:1774])
1774-71
sum(c(rep(0,1703),rep(1,71),rep(0,71))[1:1774])
find_genes_df <- data.frame(matrix(0,nrow = nrow(ggC_intermed_gene_presence_absence_consensus)-1, ncol = 50))
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),75)[i:(nrow(ggC_intermed_gene_presence_absence_consensus)-2 + i)]
find_genes_df[,i+25] <- c(rep(0,1703),rep(1,71),rep(0,71))[i:(nrow(ggC_intermed_gene_presence_absence_consensus)-2 + i)]
}
find_genes_df <- data.frame(matrix(0,nrow = nrow(ggC_intermed_gene_presence_absence_consensus)-1, ncol = 50))
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),75)[i:(nrow(ggC_intermed_gene_presence_absence_consensus)-2 + i)]
find_genes_df[,i+25] <- c(rep(0,1703),rep(1,71),rep(0,1703))[(1 + (i-1) * 71) : (nrow(ggC_intermed_gene_presence_absence_consensus)-2 + + (i-1) * 71)]
}
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),75)[i:(nrow(ggC_intermed_gene_presence_absence_consensus)-2 + i)]
find_genes_df[,i+25] <- c(rep(0,1703),rep(1,71),rep(0,1703))[(1 + (i-1) * 71) : (nrow(ggC_intermed_gene_presence_absence_consensus)-2 + (i-1) * 71)]
}
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),75)[i:(nrow(ggC_intermed_gene_presence_absence_consensus)-2 + i)]
find_genes_df[,i+25] <- c(rep(0,1703),rep(1,71),rep(0,1703))[(1 + (i-1) * 71) : (nrow(ggC_intermed_gene_presence_absence_consensus)-1 + (i-1) * 71)]
}
fitting_closure_FindGenes <- function(all_other_params, data1, data2){
null_fit_dfoptim <- function(fit_params){
params <- c(all_other_params, sigma_f = fit_params[1], m = fit_params[2], v = fit_params[3])
WF_findGenes_model <- WF_findGenes$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WF_findGenes_model$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WF_findGenes_model$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
combined_compare(x[,1,37],data1) + combined_compare(x[,1,73],data2)
}
}
FindGenes_all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3, delta_bool = as.double(nfds_gene_bool), m = 0.005, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.05, vacc_time = 0)
fit_FindGenes_ggCPP <- fitting_closure_FindGenes(FindGenes_all_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
FindGenes_ggCPP_optim_fit <- nmkb(c(0.15, 0.03, 0.05), fit_FindGenes_ggCPP, lower=c(0,0,0), upper=c(1,1,1), control = c(maximize = TRUE))
FindGenes_ggCPP_optim_fit$par
FindGenes_ggCPP_optim_fit$value
for (i in 1:10){
FindGenes_all_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3, delta_bool = as.double(find_genes_df[,i]), m = 0.005, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.05, vacc_time = 0)
fit_FindGenes_ggCPP <- fitting_closure_FindGenes(FindGenes_all_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
FindGenes_ggCPP_optim_fit <- nmkb(c(0.15, 0.03, 0.05), fit_FindGenes_ggCPP, lower=c(0,0,0), upper=c(1,1,1), control = c(maximize = TRUE))
print(FindGenes_ggCPP_optim_fit$par)
print(FindGenes_ggCPP_optim_fit$value)
}
1774/25
ceiling(1774/25)
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
## command line arguments
args <- commandArgs(trailingOnly = TRUE)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_FindGenes.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
#delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# compute boolean gene vectors
n_groups <- ceiling((nrow(intermed_gene_presence_absence_consensus)-1)/25)
find_genes_df <- data.frame(matrix(0,nrow = nrow(intermed_gene_presence_absence_consensus)-1, ncol = 50))
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),(n_groups + 4))[i:(nrow(intermed_gene_presence_absence_consensus)-2 + i)]
find_genes_df[,i+25] <- c(rep(0,(nrow(intermed_gene_presence_absence_consensus) - 1-n_groups)),rep(1,n_groups),rep(0,(nrow(intermed_gene_presence_absence_consensus) - 1-n_groups)))[(1 + (i-1) * n_groups) : (nrow(intermed_gene_presence_absence_consensus)-1 + (i-1) * n_groups)]
}
print(output_filename)
for (i in 1:50) {
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
#pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta_bool <- find_genes_df[,i]
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta_bool, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta_bool = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 3) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
#mcmc_pars$initial()
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
#print(parameter_mean_hpd)
#det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
#pdf(file = paste(output_filename,"det_mcmc1.pdf",sep = "_"),   # The directory you want to save the file in
#    width = 6, # The width of the plot in inches
#    height = 12)
#plot(det_mcmc1)
#dev.off()
#print("det_mcmc_1 log likelihood")
#processed_chains$probabilities[nrow(processed_chains$probabilities),2]
#print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
#pdf(file = paste(output_filename,"det_mcmc2.pdf",sep = "_"),   # The directory you want to save the file in
#    width = 6, # The width of the plot in inches
#    height = 12)
#plot(det_mcmc2)
#dev.off()
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 500, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print("Iteration round")
print(i)
parameter_mean_hpd
print("det_mcmc_2 log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
}
for (i in 1:50) {
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
#pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta_bool <- find_genes_df[,i]
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta_bool, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta_bool = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 3) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
#mcmc_pars$initial()
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
#print(parameter_mean_hpd)
#det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
#pdf(file = paste(output_filename,"det_mcmc1.pdf",sep = "_"),   # The directory you want to save the file in
#    width = 6, # The width of the plot in inches
#    height = 12)
#plot(det_mcmc1)
#dev.off()
#print("det_mcmc_1 log likelihood")
#processed_chains$probabilities[nrow(processed_chains$probabilities),2]
#print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[2], min = 0, max = 1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[3], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 5000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
#pdf(file = paste(output_filename,"det_mcmc2.pdf",sep = "_"),   # The directory you want to save the file in
#    width = 6, # The width of the plot in inches
#    height = 12)
#plot(det_mcmc2)
#dev.off()
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 500, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print("Iteration round")
print(i)
parameter_mean_hpd
print("det_mcmc_2 log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
}
