#complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, species_no, gene_no, vacc_time, dt, migVec,vT)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#proposal_matrix[1,1] <- exp(0.1)
#proposal_matrix[3,3] <- exp(0.1)
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#WF_model <- WF$new(pars = list(), time = 0, n_particles = 1L)
#index(WF$info())
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = -2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(c(exp(1), 0.1, exp(1), 0.1))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
#n_chains = 8, n_workers = 8,
#n_threads_total = 8
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
pdf(file = paste(output_filename,"4param_det_mcmc1.pdf",sep = "_"),   # The directory you want to save the file in
width = 6, # The width of the plot in inches
height = 12)
plot(det_mcmc1)
dev.off()
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[2], min = 0, max = 1),mcstate::pmcmc_parameter("m", parameter_mean_hpd[3], min = -1000, max = 0), mcstate::pmcmc_parameter("v", parameter_mean_hpd[4], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
n_steps <- 20000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4, n_workers = 4, n_threads_total = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 2000, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
pdf(file = paste(output_filename,"_4param_det_mcmc2.pdf",sep = "_"),   # The directory you want to save the file in
width = 6, # The width of the plot in inches
height = 12)
plot(det_mcmc2)
dev.off()
print("det_mcmc_2 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
saveRDS(det_pmcmc_run2, paste(output_filename, "_4param_det_pmcmc_run2.rds", sep = ""))
} else if(params_total == 5){
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero_2vacc_5param.R")
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2
, dt = dt, migVec = (migVec), sero_no = sero_no)
#complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, species_no, gene_no, vacc_time, dt, migVec,vT)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#proposal_matrix[1,1] <- exp(0.1)
#proposal_matrix[3,3] <- exp(0.1)
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#WF_model <- WF$new(pars = list(), time = 0, n_particles = 1L)
#index(WF$info())
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = -2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(c(exp(1), 0.1, exp(1), exp(1), 0.1))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-3.4, max=0), min = -3.5, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=-3.6), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
#n_chains = 8, n_workers = 8,
#n_threads_total = 8
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
pdf(file = paste(output_filename,"5param_det_mcmc1.pdf",sep = "_"),   # The directory you want to save the file in
width = 6, # The width of the plot in inches
height = 12)
plot(det_mcmc1)
dev.off()
print("det_mcmc_1 final log likelihood")
print(processed_chains$probabilities[nrow(processed_chains$probabilities),2])
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
print(det_proposal_matrix <- cov(processed_chains$pars))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = -3.5, max = 0), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[2], min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[3], min = -1000, max = -3.5),mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = -1000, max = 0), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
n_steps <- 20000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4, n_workers = 4, n_threads_total = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 2000, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
pdf(file = paste(output_filename,"_5param_det_mcmc2.pdf",sep = "_"),   # The directory you want to save the file in
width = 6, # The width of the plot in inches
height = 12)
plot(det_mcmc2)
dev.off()
print("det_mcmc_2 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
saveRDS(det_pmcmc_run2, paste(output_filename, "_5param_det_pmcmc_run2.rds", sep = ""))
} else{
print(paste("Number of parameters chosen not okay:", params_total))
}
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero_2vacc_5param.R")
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2
, dt = dt, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = -2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(c(exp(1), 0.1, exp(1), exp(1), 0.1))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-3.4, max=0), min = -3.5, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=-3.6), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=0), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 10
n_steps <- 10
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 2, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
print(processed_chains$probabilities[nrow(processed_chains$probabilities),2])
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero_2vacc_5param.R")
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2
, dt = dt, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = -2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(c(exp(1), 0.1, exp(1), exp(1), 0.1))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-3.4, max=0), min = -3.5, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=-3.6), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=0), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 10
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 2, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
print("det_mcmc_1 final log likelihood")
print(processed_chains$probabilities[nrow(processed_chains$probabilities),2])
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 25, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print(processed_chains$probabilities[nrow(processed_chains$probabilities),2])
exp(-2 - 100)
exp(-100)
exp(-2)
exp(-2)+exp(-100)
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero_2vacc_5param.R")
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero_2vacc_5param.R")
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2
, dt = dt, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = -2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(c(exp(1), 0.1, exp(1), exp(1), 0.1))
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-3.4, max=0), min = -3.5, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=-3.6), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", runif(n=1, min=0, max=1), min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", runif(n=1, min=-1000, max=0), min = -1000, max = -3.5), mcstate::pmcmc_parameter("m", runif(n=1, min=-10, max=0), min = -1000, max = 0), mcstate::pmcmc_parameter("v", runif(n=1, min=0, max=1), min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 25, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print(processed_chains$probabilities[nrow(processed_chains$probabilities),2])
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)
.025 + .975
# 5-parameter model
Mass_5param_mcmc2 <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_12_05/ModelComparison_Mass/PPxSero_ggCaller_PopPUNK_5param_det_pmcmc_run2.rds")
Mass_5param_mcmc2_probs <- coda::as.mcmc(cbind(Mass_5param_mcmc2$probabilities, Mass_5param_mcmc2$pars))
summary(coda::as.mcmc(Mass_5param_mcmc2_probs))
# Null model
UK_2param_mcmc2 <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_12_05/ModelComparison_UK/UK_PPxSero_ggCaller_PopPUNK_Null_det_pmcmc_run2.rds")
# Null model
UK_2param_mcmc2 <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_12_05/ModelComparison_UK/UK_PPxSero_ggCaller_PopPUNK_Null_det_pmcmc_run2.rds")
UK_2param_mcmc2_probs <- coda::as.mcmc(cbind(UK_2param_mcmc2$probabilities, UK_2param_mcmc2$pars))
UK_2param_mcmc2_probs <- coda::as.mcmc(cbind(UK_2param_mcmc2$probabilities, UK_2param_mcmc2$pars))
#coda::effectiveSize(UK_2param_mcmc2_probs)
#summary(coda::as.mcmc(UK_2param_mcmc2_probs))
UK_likelihood_2param <- median(UK_2param_mcmc2_probs[,"log_likelihood"])
#mean(UK_2param_mcmc2_probs[,"log_likelihood"])
param_median <- apply(UK_2param_mcmc2_probs, 2, median)
percentile95_low <- apply(UK_2param_mcmc2_probs,2,quantile,.025)
percentile95_up <- apply(UK_2param_mcmc2_probs,2,quantile,.975)
param_median
percentile95_low
percentile95_up
#     log_prior log_likelihood  log_posterior              m              v
#    0.00000000  -640.85538465  -640.85538465    -4.36018953     0.02798267
#    0.00000000  -643.95162152  -643.95162152    -4.56306240     0.02164408
#    0.00000000  -640.17013460  -640.17013460    -4.16166788     0.03482034
rm(UK_2param_mcmc2)
# 3-parameter model
UK_3param_mcmc2 <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_12_05/ModelComparison_UK/UK_PPxSero_ggCaller_PopPUNK_3param_det_pmcmc_run2.rds")
# 3-parameter model
UK_3param_mcmc2 <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_12_05/ModelComparison_UK/UK_PPxSero_ggCaller_PopPUNK_3param_det_pmcmc_run2.rds")
UK_3param_mcmc2_probs <- coda::as.mcmc(cbind(UK_3param_mcmc2$probabilities, UK_3param_mcmc2$pars))
#mean(UK_3param_mcmc2_probs[,"log_likelihood"])
param_median <- apply(UK_3param_mcmc2_probs, 2, median)
percentile95_low <- apply(UK_3param_mcmc2_probs,2,quantile,.025)
percentile95_up <- apply(UK_3param_mcmc2_probs,2,quantile,.975)
param_median
percentile95_low
percentile95_up
#     log_prior log_likelihood  log_posterior        sigma_f              m              v
#    0.00000000  -642.10337603  -642.10337603   -19.07597327    -4.52497824     0.02894815
#    0.00000000  -652.65879091  -652.65879091  -307.70593047    -4.75223182     0.02277319
#     0.0000000   -640.2573559   -640.2573559     -4.2676913     -2.4375028      0.6825091
rm(UK_3param_mcmc2)
# 4-parameter model
UK_4param_mcmc2 <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_12_05/ModelComparison_UK/UK_PPxSero_ggCaller_PopPUNK_4param_det_pmcmc_run2.rds")
UK_4param_mcmc2_probs <- coda::as.mcmc(cbind(UK_4param_mcmc2$probabilities, UK_4param_mcmc2$pars))
#mean(UK_4param_mcmc2_probs[,"log_likelihood"])
param_median <- apply(UK_3param_mcmc2_probs, 2, median)
percentile95_low <- apply(UK_3param_mcmc2_probs,2,quantile,.025)
percentile95_up <- apply(UK_3param_mcmc2_probs,2,quantile,.975)
param_median
percentile95_low
percentile95_up
#     log_prior log_likelihood  log_posterior        sigma_f              m              v
#    0.00000000  -642.10337603  -642.10337603   -19.07597327    -4.52497824     0.02894815
#    0.00000000  -652.65879091  -652.65879091  -307.70593047    -4.75223182     0.02277319
#     0.0000000   -640.2573559   -640.2573559     -4.2676913     -2.4375028      0.6825091
rm(UK_4param_mcmc2)
exp(-300)
#mean(UK_4param_mcmc2_probs[,"log_likelihood"])
param_median <- apply(UK_4param_mcmc2_probs, 2, median)
percentile95_low <- apply(UK_4param_mcmc2_probs,2,quantile,.025)
percentile95_up <- apply(UK_4param_mcmc2_probs,2,quantile,.975)
param_median
percentile95_low
percentile95_up
