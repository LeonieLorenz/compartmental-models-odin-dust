list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
vaccTypes1 <- vaccTypes1
vaccTypes2 <- vaccTypes2
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
vaccTypes1
length(vaccTypes1)
length(vaccTypes2)
length(unname(PCV7_VTs))
vaccTypes1 <- unname(PCV7_VTs)
length(vaccTypes1)
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes1 <- vaccTypes1
vaccTypes2 <- vaccTypes2
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
#mass_VT <- readRDS(file = "Navajo_SeroVT.rds")
PCV13_VTs <- rep(0,sero_no)
names(PCV13_VTs) <- unique(seq_clusters$Serotype)
PCV13_VTs[intersect(names(PCV13_VTs), c("1", "3", "4","5","6A","6B", "7F", "9V", "14", "18C", "19A", "19F", "23F"))] <- 1
vaccTypes2 <- unname(PCV13_VTs)
vaccTypes1 <- vaccTypes1
vaccTypes2 <- vaccTypes2
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
UK_mass_VT2 <- <- readRDS(file = "UK_SeroVT_PCV13.rds")
UK_mass_VT2 <- readRDS(file = "UK_SeroVT_PCV13.rds")
UK_mass_VT2
length(UK_mass_VT2)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)
plot(det_mcmc1)
plot(det_mcmc1)
seq_clusters <- readRDS("UK_PP.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "UK_ggCaller_intermed_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
mass_clusters <- length(unique(seq_clusters$Cluster))
delta_ranking <- readRDS(file = "UK_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "UK_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "UK_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "UK_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "UK_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "UK_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "UK_cluster_freqs_6.rds")
mass_cluster_freq_7 <- readRDS(file = "UK_cluster_freqs_7.rds")
avg_cluster_freq <- readRDS(file = "UK_PPsero_mig.rds")
output_filename <- "UK_PPxSero_ggCaller_PopPUNK"
mass_clusters <- length(unique(seq_clusters$Cluster))
sero_no = length(unique(seq_clusters$Serotype))
sero_no
PCV13_VTs <- rep(0,sero_no)
names(PCV13_VTs) <- unique(seq_clusters$Serotype)
PCV13_VTs[c("1", "3", "4","5","6A","6B", "7F", "9V", "14", "18C", "19A", "19F", "23F")] <- 1
vaccTypes2 <- unname(PCV13_VTs)
PCV13_VTs <- rep(0,sero_no)
names(PCV13_VTs) <- unique(seq_clusters$Serotype)
PCV13_VTs[intersect(PCV13_VTs,c("1", "3", "4","5","6A","6B", "7F", "9V", "14", "18C", "19A", "19F", "23F"))] <- 1
vaccTypes2 <- unname(PCV13_VTs)
# add 6A to PCV7 because there is strong cross-immunity btw PVC7 and 6A (4.Croucher, N. J. et al. Population genomics of post-vaccine changes in pneumococcal epidemiology. Nat. Genet. 45, 656–663 (2013).)
PCV7_VTs <- rep(0,sero_no)
names(PCV7_VTs) <- unique(seq_clusters$Serotype)
PCV7_VTs[intersect(PCV7_VTs,c("4","6A", "6B", "9V", "14", "18C", "19F", "23F"))] <- 1
vaccTypes1 <- unname(PCV7_VTs)
length(vaccTypes1)
dt <- 1/12
peripost_mass_cluster_freq <- data.frame("year" = 1:6, rbind(mass_cluster_freq_2,mass_cluster_freq_3,mass_cluster_freq_4,mass_cluster_freq_5,mass_cluster_freq_6, mass_cluster_freq_7))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
vacc_time1 <- 0
vacc_time2 <- 4
sero_no = length(unique(seq_clusters$Serotype))
model_start_pop <- readRDS(file = "UK_PPsero_startpop.rds")
mass_VT2 <- readRDS(file = "UK_SeroVT_PCV13.rds")
length(mass_VT2)
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes1 <- vaccTypes1
vaccTypes2 <- vaccTypes2
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes1 = vaccTypes1, vaccTypes2 = vaccTypes2, gene_no = gene_no, vacc_time1 = vacc_time1, vacc_time2 = vacc_time2, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
## PPxSero_2vacc fits
# Param estimates for PPxSero
# Navajo
Navajo_PPxSero2vacc <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_08_23/Navajo_PPxSero2vacc_ggCaller_PopPUNK_det_pmcmc_run2.rds")
## PPxSero_2vacc fits
# Param estimates for PPxSero
# Navajo
Navajo_PPxSero2vacc <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_08_23/Navajo_PPxSero2vacc/Navajo_PPxSero2vacc_ggCaller_PopPUNK_det_pmcmc_run2.rds")
## PPxSero_2vacc fits
# Param estimates for PPxSero
# Navajo
Navajo_PPxSero2vacc <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_08_23/Navajo_PPxSero2vacc/Navajo_PPxSero2vacc_ggCaller_PopPUNK_det_pmcmc_run2.rds")
Navajo_PPxSero_mcmc <- coda::as.mcmc(cbind(Navajo_PPxSero2vacc$probabilities, Navajo_PPxSero2vacc$pars))
coda::effectiveSize(Navajo_PPxSero_mcmc)
summary(coda::as.mcmc(Navajo_PPxSero_mcmc))
# UK
UK_PPxSero2vacc <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_08_23/UK_PPxSero2vacc/UK_PPxSero2vacc_ggCaller_PopPUNK_det_pmcmc_run2.rds")
# UK
UK_PPxSero2vacc <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_08_23/UK_PPxSero2vacc/UK_PPxSero_ggCaller_PopPUNK_det_pmcmc_run2.rds")
UK_PPxSero_mcmc <- coda::as.mcmc(cbind(UK_PPxSero2vacc$probabilities, UK_PPxSero2vacc$pars))
coda::effectiveSize(UK_PPxSero_mcmc)
summary(coda::as.mcmc(UK_PPxSero_mcmc))
exp(-2.8)
exp(-0.3)
mass_cluster_freq_1 <- readRDS(file = "UK_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "UK_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "UK_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "UK_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "UK_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "UK_cluster_freqs_6.rds")
mass_cluster_freq_7 <- readRDS(file = "UK_cluster_freqs_7.rds")
sum_UK_data <- (mass_cluster_freq_1 + mass_cluster_freq_2 + mass_cluster_freq_3 + mass_cluster_freq_4 + mass_cluster_freq_5 + mass_cluster_freq_6 + mass_cluster_freq_7)
count_cluster_size_UK <- rep(0, (max(sum_UK_data) +1) )
for (i in 1:(max(sum_UK_data) +1)) {
count_cluster_size_UK[i] <- length(which(sum_UK_data == i))
}
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6))
lines((dpois(0:80,8) + dpois(0:80,1))/sum(dpois(0:80,8) + dpois(0:80,1)), col = "red")
lines(dnbinom(0:80, 1, mu =1, log = FALSE))
lines(dnbinom(0:80, 10, mu =1, log = FALSE))
plot(dnbinom(0:80, 10, mu =1, log = FALSE), ylim = c(0,1))
lines(dnbinom(0:80, 1, mu =1, log = FALSE))
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6))
lines((dpois(0:80,8), col = "red")
lines((dpois(0:80,8)), col = "red")
lines((dpois(0:80,0)), col = "red")
lines((dpois(0:80,1)), col = "red")
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poissoin distribution")
lines((dpois(0:80,8)), col = "red")
lines((dpois(0:80,1)), col = "blue")
legend(60, 0.6, legend=c("Pois(8)", "Pois(1)"),
col=c("red", "blue"), lty=1:2, cex=0.8)
legend(60, 0.6, legend=c("Pois(8)", "Pois(1)"),
col=c("red", "blue"), lty=1, cex=0.8)
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Index", ylab = "relative cluster size")
lines((dpois(0:80,8)), col = "red")
lines((dpois(0:80,1)), col = "blue")
legend(60, 0.6, legend=c("Pois(8)", "Pois(1)"),
col=c("red", "blue"), lty=1, cex=1.2)
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution")
lines((dpois(0:80,8) + dpois(0:80,1))/sum(dpois(0:80,8) + dpois(0:80,1)), col = "red")
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines((dpois(0:80,8)), col = "red")
lines((dpois(0:80,1)), col = "blue")
legend(60, 0.6, legend=c("Pois(8)", "Pois(1)"),
col=c("red", "blue"), lty=1, cex=1.2)
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines((dpois(0:80,8) + dpois(0:80,1))/sum(dpois(0:80,8) + dpois(0:80,1)), col = "red")
lines((dpois(0:80,8) + dpois(0:80,0))/sum(dpois(0:80,8) + dpois(0:80,1)), col = "red")
plot(count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines((dpois(0:80,8) + dpois(0:80,0))/sum(dpois(0:80,8) + dpois(0:80,1)), col = "red")
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines((dpois(0:80,8)), col = "red")
lines((dpois(0:80,1)), col = "blue")
count_cluster_size_UK <- rep(0, (max(sum_UK_data) +1) )
for (i in 0:(max(sum_UK_data))) {
count_cluster_size_UK[i+1] <- length(which(sum_UK_data == i))
}
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
sum_UK_data
count_cluster_size_UK <- rep(0, (max(sum_UK_data) +1) )
for (i in 0:(max(sum_UK_data))) {
count_cluster_size_UK[i+1] <- length(which(sum_UK_data == i))
}
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines((dpois(0:80,8)), col = "red")
lines((dpois(0:80,1)), col = "blue")
lines(0:max(sum_UK_data),(dpois(0:80,8)), col = "red")
lines(0:max(sum_UK_data),(dpois(0:81,8)), col = "red")
length(0:max(sum_UK_data))
lines(0:max(sum_UK_data),(dpois(0:76,8)), col = "red")
lines(0:max(sum_UK_data),(dpois(0:76,1)), col = "blue")
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(sum_UK_data),(dpois(0:76,8)), col = "red")
lines(0:max(sum_UK_data),(dpois(0:76,1)), col = "blue")
legend(60, 0.6, legend=c("Pois(8)", "Pois(1)"),
col=c("red", "blue"), lty=1, cex=1.2)
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(sum_UK_data),(dpois(0:76,8) + dpois(0:76,0))/sum(dpois(0:76,8) + dpois(0:76,1)), col = "red")
lines(dnbinom(0:80, 1, mu =1, log = FALSE))
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(sum_UK_data),(dpois(0:76,8) + dpois(0:76,0))/sum(dpois(0:76,8) + dpois(0:76,1)), col = "red")
lines(0:max(sum_UK_data),(dpois(0:76,8) + dpois(0:76,1))/sum(dpois(0:76,8) + dpois(0:76,1)), col = "red")
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(sum_UK_data),(dpois(0:76,8) + dpois(0:76,1))/sum(dpois(0:76,8) + dpois(0:76,1)), col = "red")
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(sum_UK_data),(dpois(0:76,8) + dpois(0:76,0))/sum(dpois(0:76,8) + dpois(0:76,0)), col = "red")
plot(0:max(sum_UK_data),count_cluster_size_UK/sum(count_cluster_size_UK), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(sum_UK_data),(dpois(0:76,8) + dpois(0:76,1))/sum(dpois(0:76,8) + dpois(0:76,1)), col = "red")
# wait, how about just one year?
counts_UK_1 <- rep(0, (max(mass_cluster_freq_1) +1) )
for (i in 0:(max(mass_cluster_freq_1))) {
counts_UK_1[i+1] <- length(which(mass_cluster_freq_1 == i))
}
counts_UK_1
mass_cluster_freq_1
max(mass_cluster_freq_1)
plot(0:max(mass_cluster_freq_1),counts_UK_1/sum(counts_UK_1), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(mass_cluster_freq_1),(dpois(0:9,8)), col = "red")
plot(0:max(mass_cluster_freq_1),counts_UK_1/sum(counts_UK_1), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
0:max(mass_cluster_freq_1)
plot(0:max(mass_cluster_freq_1),counts_UK_1/sum(counts_UK_1), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(mass_cluster_freq_1),(dpois(0:9,8)), col = "red")
length( 0:max(mass_cluster_freq_1))
plot(0:max(mass_cluster_freq_1),counts_UK_1/sum(counts_UK_1), ylim = c(0,0.6), main = "Southampton counts vs. Poisson distribution", xlab = "Cluster Size", ylab = "relative counts of cluster size")
lines(0:max(mass_cluster_freq_1),(dpois(0:10,8)), col = "red")
lines(0:max(mass_cluster_freq_1),(dpois(0:10,1)), col = "blue")
lines(0:max(mass_cluster_freq_1),(dpois(0:10,)), col = "blue")
lines(0:max(mass_cluster_freq_1),(dpois(0:10,0)), col = "blue")
path_to_data <- "~/Documents/PhD_Project/Data/"
library(readxl)
Navajo_meta_data <- read_excel(paste(path_to_data, "StrepPneumo_Navajo/metadata.xlsx", sep = ""))
Navajo_time_points <- sort(unique(Navajo_meta_data$Year))
Navajo_SeqYear_dict <- Navajo_meta_data$Year
names(Navajo_SeqYear_dict) <- Navajo_meta_data$Accession
Navajo_meta_IDtoInd <- 1:nrow(Navajo_meta_data)
names(Navajo_meta_IDtoInd) <- Navajo_meta_data$Accession
Navajo_time_seq <- Navajo_time_points[1]:Navajo_time_points[length(Navajo_time_points)]
seq_no_per_year <- rep(0, length(Navajo_time_seq))
names(seq_no_per_year) <- Navajo_time_seq
for (i in 1:length(Navajo_time_seq)) {
seq_no_per_year[i] <- length(which(Navajo_meta_data$Year==Navajo_time_seq[i]))
}
barplot(seq_no_per_year, xlab = "Sequencing Years", ylab = "Sequence Counts", col = rainbow(15))
# PCV7 was introduced in 2000
# PCV13 was introduced in 2010
# according to Azarian et al. (2018) https://doi.org/10.1371/journal.ppat.1006966
#
Navajo_time_points_selected <- Navajo_time_seq
Navajo_time_points_preVac1 <- Navajo_time_seq[1:4]
Navajo_time_points_preVac2 <- Navajo_time_seq[1:13]
### Reading in the Accession Codes, Population and the Sequence Clusters
UK_metadata <- read.csv("~/Documents/PhD_Project/Data/StrepPneumo_UK/metadata.csv")
UK_ids <- UK_metadata$id
UK_ids_dict <- 1:length(UK_ids)
names(UK_ids_dict) <- UK_ids
UK_id_acc_dict <- UK_ids
names(UK_id_acc_dict) <- UK_metadata$Accession
#Isolates <- Samples_accCodes$`Isolate Name`
#Isolates_dict <- 1:length(Isolates)
#names(Isolates_dict) <- Isolates
#Isolate_from_Mass_dict <- rep(0, length(Isolates))
#names(Isolate_from_Mass_dict) <- Isolates
#Isolate_from_Mass_dict[Mass_Isolates] <- 1
split_winter <- function(winter){
strsplit(winter,"\\/")[[1]][1]
}
UK_SeqYear_dict <- sapply(UK_metadata$Winter, split_winter)
#names(UK_SeqYear_dict) <- UK_ids
names(UK_SeqYear_dict) <- UK_metadata$Accession
UK_meta_IDtoInd <- 1:nrow(UK_metadata)
names(UK_meta_IDtoInd) <- UK_metadata$Accession
UK_time_points <- sort(unique(UK_SeqYear_dict))
UK_winters <- sort(unique(UK_metadata$Winter))
UK_SeqYear_dict
unique(UK_SeqYear_dict)
path_to_data <- "~/Documents/PhD_Project/Data/"
Nepal_meta_data <- read.csv(paste(path_to_data, "StrepPneumo_Nepal/monocle-metadata-from-sample-download.csv",sep = ""))
Nepal_time_points <- sort(unique(Nepal_meta_data$Year))
Nepal_SeqYear_dict <- Nepal_meta_data$Year
names(Nepal_SeqYear_dict) <- Nepal_meta_data$Lane_id
Nepal_meta_IDtoInd <- 1:nrow(Nepal_meta_data)
names(Nepal_meta_IDtoInd) <- Nepal_meta_data$Lane_id
unique(Nepal_SeqYear_dict)
