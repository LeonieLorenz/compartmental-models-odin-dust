progress = TRUE,
n_chains = 1)
pmcmc_run <- mcstate::pmcmc(pars, filter, control = control)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 2, n_workers = 2,n_threads_total = 2)
pmcmc_run <- mcstate::pmcmc(pars, filter, control = control)
pmcmc_run$probabilities
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
library(coda)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_VT.R")
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
#data_size <- sum(unlist(observed))
#print(state)
#state_length <- length(state)
#new_state <- (state[2:(state_length/2 + 1), , drop = TRUE]) + (state[(state_length/2 + 2):(state_length), , drop = TRUE])
#state <- new_state
data_size <- sum(unlist(observed))
#model_size = sum(unlist(state))
model_size = sum(unlist(state["sum_clust", , drop = TRUE]))
exp_noise <- 1e6
if (is.na(observed)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length( state["sum_clust", , drop = TRUE]/model_size * data_size))
} else {
lambda <-  state["sum_clust", , drop = TRUE]/model_size * data_size + rexp(n = length( state["sum_clust", , drop = TRUE]/model_size * data_size), rate = exp_noise)
ll_obs <- dpois(x = observed, lambda = lambda, log = TRUE)
}
result <- ll_obs
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
#delta_ranking <- readRDS(file = "ggC_delta_ranking3.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
#mass_VT <- readRDS(file = "PP_mass_VT_mean.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "4param_ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
# we have data from 2001, 2004, 2007, so we want 3 (years) * 12 (months) = 36 updates in-between
ceil_mass_NVT <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
ceil_mass_NVT[i] <- ceiling(mean(as.integer(seq_clusters[seq_clusters$Cluster == unique(seq_clusters$Cluster)[i],"VT"]=="NVT")))
}
#ceil_mass_NVT[is.nan(ceil_mass_NVT)] <- 0
mean_mass_VT_2001 <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
mean_mass_VT_2001[i] <- (mean(as.integer(seq_clusters[seq_clusters$SeqYear == 2001 & seq_clusters$Cluster == unique(seq_clusters$Cluster)[i],"VT"]=="VT")))
}
mean_mass_VT_2001[is.nan(mean_mass_VT_2001)] <- 0
NVT_mig <- rep(1/mass_clusters, mass_clusters) * (ceil_mass_NVT)
VT_mig <- rep(1/mass_clusters, mass_clusters) * (1-ceil_mass_NVT)
avg_cluster_freq <- data.frame(as.matrix(cbind(NVT_mig,VT_mig)))
model_start_pop <- matrix(as.double(c(model_start_pop * (1-mean_mass_VT_2001),model_start_pop * mean_mass_VT_2001)), byrow = FALSE, nrow = mass_clusters, ncol = 2)
output_filename <- "VT_ggCaller_PopPUNK"
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
vacc_time <- 0
threads_total <- 1
worker_nodes <- 1
stoch_run <- FALSE
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vT = c(0,1)
migVec <- avg_cluster_freq
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vT = vT, gene_no = gene_no, vacc_time = vacc_time, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec))
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
index(WF$info())
WF$info()
WFmodel <- WF$new(pars = ggCPP_params,
time = 0,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
WFmodel$info(())
WFmodel$info()
WF <- odin.dust::odin_dust("NFDS_Model_VT.R")
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
#delta_ranking <- readRDS(file = "ggC_delta_ranking3.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
#mass_VT <- readRDS(file = "PP_mass_VT_mean.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "4param_ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
# we have data from 2001, 2004, 2007, so we want 3 (years) * 12 (months) = 36 updates in-between
ceil_mass_NVT <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
ceil_mass_NVT[i] <- ceiling(mean(as.integer(seq_clusters[seq_clusters$Cluster == unique(seq_clusters$Cluster)[i],"VT"]=="NVT")))
}
#ceil_mass_NVT[is.nan(ceil_mass_NVT)] <- 0
mean_mass_VT_2001 <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
mean_mass_VT_2001[i] <- (mean(as.integer(seq_clusters[seq_clusters$SeqYear == 2001 & seq_clusters$Cluster == unique(seq_clusters$Cluster)[i],"VT"]=="VT")))
}
mean_mass_VT_2001[is.nan(mean_mass_VT_2001)] <- 0
NVT_mig <- rep(1/mass_clusters, mass_clusters) * (ceil_mass_NVT)
VT_mig <- rep(1/mass_clusters, mass_clusters) * (1-ceil_mass_NVT)
avg_cluster_freq <- as.matrix(cbind(NVT_mig,VT_mig))
model_start_pop <- matrix(as.double(c(model_start_pop * (1-mean_mass_VT_2001),model_start_pop * mean_mass_VT_2001)), byrow = FALSE, nrow = mass_clusters, ncol = 2)
output_filename <- "VT_ggCaller_PopPUNK"
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
vacc_time <- 0
ggCPP_params <- list(dt = 1/12, species_no =mass_clusters,  gene_no = nrow(intermed_gene_presence_absence_consensus)-1, Pop_ini = ( model_start_pop), Pop_eq = Pop_eq <- rowSums(model_start_pop), capacity = sum( model_start_pop), Genotypes = intermed_gene_presence_absence_consensus_matrix, sigma_f = -2.4253023, prop_f = 0.1009613, sigma_w =-1000 , delta = delta_ranking, m = -3.9979980, migVec =  avg_cluster_freq, v = 0.1056966 , vT = c(0,1), migVec = VT_mig, vacc_time = 0)
WFmodel <- WF$new(pars = ggCPP_params,
time = 0,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
WFmodel$info()
model_start_pop
WFmodel$info()$index$Pop_tot
WFmodel$info()
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
WF_model <- WF$new(pars = list(), time = 0, n_particles = 1L)
index(WF_model$info())
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
filter$run(save_history = TRUE, pars = list(dt = dt))
dimnames(filter$history())
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
WFmodel <- WF$new(pars = ggCPP_params,
time = 0,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
index(WFmodel$info())
index(WFmodel$info())$run
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
#data_size <- sum(unlist(observed))
#print(state)
#state_length <- length(state)
#new_state <- (state[2:(state_length/2 + 1), , drop = TRUE]) + (state[(state_length/2 + 2):(state_length), , drop = TRUE])
#state <- new_state
data_size <- sum(unlist(observed))
#model_size = sum(unlist(state))
model_size = sum(unlist(state[-1, , drop = TRUE]))
exp_noise <- 1e6
if (is.na(observed)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length( state[-1, , drop = TRUE]/model_size * data_size))
} else {
lambda <-  state[-1, , drop = TRUE]/model_size * data_size + rexp(n = length( state[-1, , drop = TRUE]/model_size * data_size), rate = exp_noise)
ll_obs <- dpois(x = observed, lambda = lambda, log = TRUE)
}
result <- ll_obs
}
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vT = c(0,1)
migVec <- avg_cluster_freq
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vT = vT, gene_no = gene_no, vacc_time = vacc_time, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec))
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vT = vT, gene_no = gene_no, vacc_time = vacc_time, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec))
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
#data_size <- sum(unlist(observed))
#print(state)
#state_length <- length(state)
#new_state <- (state[2:(state_length/2 + 1), , drop = TRUE]) + (state[(state_length/2 + 2):(state_length), , drop = TRUE])
#state <- new_state
data_size <- sum(unlist(observed))
#model_size = sum(unlist(state))
model_size = sum(unlist(state[-1, , drop = TRUE]))
exp_noise <- 1e6
if (is.na(unlist(observed)[1])) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length( state[-1, , drop = TRUE]/model_size * data_size))
} else {
lambda <-  state[-1, , drop = TRUE]/model_size * data_size + rexp(n = length( state[-1, , drop = TRUE]/model_size * data_size), rate = exp_noise)
ll_obs <- dpois(x = observed, lambda = lambda, log = TRUE)
}
result <- ll_obs
}
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
#data_size <- sum(unlist(observed))
#print(state)
#state_length <- length(state)
#new_state <- (state[2:(state_length/2 + 1), , drop = TRUE]) + (state[(state_length/2 + 2):(state_length), , drop = TRUE])
#state <- new_state
data_size <- sum(unlist(observed))
#model_size = sum(unlist(state))
model_size = sum(unlist(state[-1, , drop = TRUE]))
exp_noise <- 1e6
#if (is.na(unlist(observed)[1])) {
# Creates vector of zeros in ll with same length, if no data
#  ll_obs <- numeric(length( state[-1, , drop = TRUE]/model_size * data_size))
#} else {
#  lambda <-  state[-1, , drop = TRUE]/model_size * data_size + rexp(n = length( state[-1, , drop = TRUE]/model_size * data_size), rate = exp_noise)
#  ll_obs <- dpois(x = observed, lambda = lambda, log = TRUE)
#}
for (i in 1:(nrow(state)-1)){
if (is.na(observed[[as.character(i)]])) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length( state[1+i, , drop = TRUE]/model_size * data_size))
} else {
lambda <-  state[1+i, , drop = TRUE]/model_size * data_size + rexp(n = length( state[1+i, , drop = TRUE]/model_size * data_size), rate = exp_noise)
ll_obs <- dpois(x = observed[[as.character(i)]], lambda = lambda, log = TRUE)
}
result <- result + ll_obs
}
result
result <- ll_obs
}
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vT = c(0,1)
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vT = vT, gene_no = gene_no, vacc_time = vacc_time, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec))
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
take_list <- function(x){
print(x$Genotype)
}
transform <- function() {
make_transform(complex_params)}
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
mcmc_pars$model(mcmc_pars$initial())
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
