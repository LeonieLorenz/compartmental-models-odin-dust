for(i in 1:length(unhelpful_params)){
for (j in 2:length(unhelpful_params)) {
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params[i]] <- 0
new_best_vec_loc[unhelpful_params[j]] <- 0
#print(which(new_best_vec==1)[i])
new_likelihood <- test_gene_vec(new_best_vec_loc)
if(new_likelihood > best_likelihood + 2){
#print(new_likelihood)
likelihood_vec[local_iter] <- new_likelihood
unhelpful_params1[local_iter] <- which(new_best_vec==1)[i]
unhelpful_params2[local_iter] <- which(new_best_vec==1)[j]
local_iter <- local_iter +1
}
}
}
#[1] -257.1697
max(likelihood_vec)
which.max(likelihood_vec)
tail(sort(likelihood_vec))
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params1[which.max(likelihood_vec)]] <- 0
new_best_vec_loc[unhelpful_params2[which.max(likelihood_vec)]] <- 0
test_gene_vec(new_best_vec_loc)
unhelpful_params1[which.max(likelihood_vec)]
unhelpful_params[i]
unhelpful_params
which(new_best_vec==1)
likelihood_vec <- c()
unhelpful_params2 <- c()
unhelpful_params1 <- c()
local_iter <- 1
for(i in 1:length(unhelpful_params)){
for (j in 2:length(unhelpful_params)) {
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params[i]] <- 0
new_best_vec_loc[unhelpful_params[j]] <- 0
#print(which(new_best_vec==1)[i])
new_likelihood <- test_gene_vec(new_best_vec_loc)
if(new_likelihood > best_likelihood + 2){
#print(new_likelihood)
likelihood_vec[local_iter] <- new_likelihood
unhelpful_params1[local_iter] <- unhelpful_params[i]
unhelpful_params2[local_iter] <- unhelpful_params[j]
local_iter <- local_iter +1
}
}
}
#[1] -257.1697
max(likelihood_vec)
which.max(likelihood_vec)
tail(sort(likelihood_vec))
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params1[which.max(likelihood_vec)]] <- 0
new_best_vec_loc[unhelpful_params2[which.max(likelihood_vec)]] <- 0
test_gene_vec(new_best_vec_loc)
which(likelihood_vec>-260)
likelihood_vec[which(likelihood_vec>-260)]
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params1[which(likelihood_vec>-260)[1]]] <- 0
new_best_vec_loc[unhelpful_params2[which(likelihood_vec>-260)[1]]] <- 0
test_gene_vec(new_best_vec_loc)
new_best_vec_loc1 <- new_best_vec
new_best_vec_loc1[unhelpful_params1[which(likelihood_vec>-260)[1]]] <- 0
new_best_vec_loc1[unhelpful_params2[which(likelihood_vec>-260)[1]]] <- 0
test_gene_vec(new_best_vec_loc1)
new_best_vec_loc2 <- new_best_vec
new_best_vec_loc2[unhelpful_params1[which(likelihood_vec>-260)[2]]] <- 0
new_best_vec_loc2[unhelpful_params2[which(likelihood_vec>-260)[2]]] <- 0
test_gene_vec(new_best_vec_loc2)
new_best_vec_loc3 <- new_best_vec
new_best_vec_loc3[unhelpful_params1[which(likelihood_vec>-260)[3]]] <- 0
new_best_vec_loc3[unhelpful_params2[which(likelihood_vec>-260)[3]]] <- 0
test_gene_vec(new_best_vec_loc3)
new_best_vec_loc4 <- new_best_vec
new_best_vec_loc4[unhelpful_params1[which(likelihood_vec>-260)[4]]] <- 0
new_best_vec_loc4[unhelpful_params2[which(likelihood_vec>-260)[4]]] <- 0
test_gene_vec(new_best_vec_loc4)
new_best_vec_loc5 <- new_best_vec
new_best_vec_loc5[unhelpful_params1[which(likelihood_vec>-260)[5]]] <- 0
new_best_vec_loc5[unhelpful_params2[which(likelihood_vec>-260)[5]]] <- 0
test_gene_vec(new_best_vec_loc5)
new_best_vec_loc6 <- new_best_vec
new_best_vec_loc6[unhelpful_params1[which(likelihood_vec>-260)[6]]] <- 0
new_best_vec_loc6[unhelpful_params2[which(likelihood_vec>-260)[6]]] <- 0
test_gene_vec(new_best_vec_loc6)
plot(new_best_vec_loc1 + new_best_vec_loc2 + new_best_vec_loc3 + new_best_vec_loc4 + new_best_vec_loc5 + new_best_vec_loc6)
best_best_vec <- new_best_vec_loc1 + new_best_vec_loc2 + new_best_vec_loc3 + new_best_vec_loc4 + new_best_vec_loc5 + new_best_vec_loc6
best_best_vec
length(new_best_vec_loc1)
best_best_vec <- rep(0, length(new_best_vec_loc1))
best_best_vec[which((new_best_vec_loc1 + new_best_vec_loc2 + new_best_vec_loc3 + new_best_vec_loc4 + new_best_vec_loc5 + new_best_vec_loc6)==6)] <- 1
best_best_vec <- rep(0, length(new_best_vec_loc1))
best_best_vec[which((new_best_vec_loc1 + new_best_vec_loc2 + new_best_vec_loc3 + new_best_vec_loc4 + new_best_vec_loc5 + new_best_vec_loc6)==6)] <- 1
test_gene_vec(best_best_vec)
# -256.7823
saveRDS(best_best_vec, "bestNFDSgenes.rds")
sum(best_best_vec)
sum(best_best_vec)/length(best_best_vec)
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_FindGenes.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
#delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# compute boolean gene vectors
n_groups <- ceiling((nrow(intermed_gene_presence_absence_consensus)-1)/25)
find_genes_df <- data.frame(matrix(0,nrow = nrow(intermed_gene_presence_absence_consensus)-1, ncol = 51))
for (i in 1:25) {
find_genes_df[,i] <- rep(c(rep(0,24),1),(n_groups + 4))[i:(nrow(intermed_gene_presence_absence_consensus)-2 + i)]
find_genes_df[,i+25] <- c(rep(0,(nrow(intermed_gene_presence_absence_consensus) - 1-n_groups)),rep(1,n_groups),rep(0,(nrow(intermed_gene_presence_absence_consensus) - n_groups)))[(1 + (i-1) * n_groups) : (nrow(intermed_gene_presence_absence_consensus)-1 + (i-1) * n_groups)]
}
ggCmanFindGeneResults <- readRDS("ggCmanSeqCl_FindGenesResults2.rds")
find_genes_df[,51] <- ggCmanFindGeneResults
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
#pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
#pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta_bool <- best_best_vec
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta_bool, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta_bool = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 3) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
#det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
#pdf(file = paste(output_filename,"det_mcmc1.pdf",sep = "_"),   # The directory you want to save the file in
#    width = 6, # The width of the plot in inches
#    height = 12)
#plot(det_mcmc1)
#dev.off()
#print("det_mcmc_1 log likelihood")
#processed_chains$probabilities[nrow(processed_chains$probabilities),2]
#print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[2], min = 0, max = 1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[3], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 2000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
#pdf(file = paste(output_filename,"det_mcmc2.pdf",sep = "_"),   # The directory you want to save the file in
#    width = 6, # The width of the plot in inches
#    height = 12)
plot(det_mcmc2)
unhelpful_params3_1 <- c()
unhelpful_params3_2 <- c()
unhelpful_params4_1 <- c()
unhelpful_params4_2 <- c()
likelihood_vec <- c()
local_iter <- 1
for(i in 1:length(unhelpful_params1)){
for (j in 2:length(unhelpful_params1)) {
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params1[i]] <- 0
new_best_vec_loc[unhelpful_params2[i]] <- 0
new_best_vec_loc[unhelpful_params1[j]] <- 0
new_best_vec_loc[unhelpful_params2[j]] <- 0
#print(which(new_best_vec==1)[i])
new_likelihood <- test_gene_vec(new_best_vec_loc)
if(new_likelihood > best_likelihood + 2){
#print(new_likelihood)
likelihood_vec[local_iter] <- new_likelihood
unhelpful_params3_1[local_iter] <- unhelpful_params1[i]
unhelpful_params3_2[local_iter] <- unhelpful_params2[i]
unhelpful_params4_1[local_iter] <- unhelpful_params1[j]
unhelpful_params4_2[local_iter] <- unhelpful_params2[j]
local_iter <- local_iter +1
}
}
}
### Likelihood
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(observed)
model_size = sum(state)
for (i in 1:length(observed)){
result <- result + ll_pois(observed[i], state[i]/model_size * data_size)
}
result
}
for(i in 1:length(unhelpful_params1)){
for (j in 2:length(unhelpful_params1)) {
new_best_vec_loc <- new_best_vec
new_best_vec_loc[unhelpful_params1[i]] <- 0
new_best_vec_loc[unhelpful_params2[i]] <- 0
new_best_vec_loc[unhelpful_params1[j]] <- 0
new_best_vec_loc[unhelpful_params2[j]] <- 0
#print(which(new_best_vec==1)[i])
new_likelihood <- test_gene_vec(new_best_vec_loc)
if(new_likelihood > best_likelihood + 2){
#print(new_likelihood)
likelihood_vec[local_iter] <- new_likelihood
unhelpful_params3_1[local_iter] <- unhelpful_params1[i]
unhelpful_params3_2[local_iter] <- unhelpful_params2[i]
unhelpful_params4_1[local_iter] <- unhelpful_params1[j]
unhelpful_params4_2[local_iter] <- unhelpful_params2[j]
local_iter <- local_iter +1
}
}
}
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_2step.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_2step.R")
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
pmcmc_prop_f_1 <- mcstate::pmcmc_parameter("prop_f_1", 0.25, min = 0, max = 1)
pmcmc_prop_f_2 <- mcstate::pmcmc_parameter("prop_f_2", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
exp(0.1)
log(0.1)
proposal_matrix[1,1] <- exp(0.1)
proposal_matrix[2,2] <- exp(0.1)
proposal_matrix[5,5] <- exp(0.1)
proposal_matrix <- diag(0.1, 6) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
proposal_matrix[1,1] <- exp(0.1)
proposal_matrix[2,2] <- exp(0.1)
proposal_matrix[5,5] <- exp(0.1)
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
log(0.1432)
log(0.0011)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", log(0.1432), min = -1000, max = 0), mcstate::pmcmc_parameter("sigma_w", log(0.0011), min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f_1", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f_2", 0.25, min = 0, max = 1),mcstate::pmcmc_parameter("m", log(0.03), min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", log(0.1432), min = -1000, max = 0), mcstate::pmcmc_parameter("sigma_w", log(0.0011), min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f_1", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f_2", 0.25, min = 0, max = 1),mcstate::pmcmc_parameter("m", log(0.03), min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
mean(processed_chains$probabilities[,2])
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = -1000, max = 0), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f_1", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("prop_f_2", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = -1000, max = 0), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
print(parameter_mean_hpd)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = -1000, max = 0), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f_1", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("prop_f_2", parameter_mean_hpd[4], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[5], min = -1000, max = 0), mcstate::pmcmc_parameter("v", parameter_mean_hpd[6], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 1000, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
print("det_mcmc_2 log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
plot(det_mcmc2)
