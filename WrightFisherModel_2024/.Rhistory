delta_ranking <- readRDS(file = "Nepal_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "Nepal_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "Nepal_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "Nepal_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "Nepal_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "Nepal_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "Nepal_cluster_freqs_6.rds")
mass_cluster_freq_7 <- readRDS(file = "Nepal_cluster_freqs_7.rds")
mass_cluster_freq_8 <- readRDS(file = "Nepal_cluster_freqs_8.rds")
mass_cluster_freq_9 <- readRDS(file = "Nepal_cluster_freqs_9.rds")
mass_cluster_freq_10 <- readRDS(file = "Nepal_cluster_freqs_10.rds")
mass_cluster_freq_11 <- readRDS(file = "Nepal_cluster_freqs_11.rds")
mass_cluster_freq_12 <- readRDS(file = "Nepal_cluster_freqs_12.rds")
mass_cluster_freq_13 <- readRDS(file = "Nepal_cluster_freqs_13.rds")
mass_cluster_freq_14 <- readRDS(file = "Nepal_cluster_freqs_14.rds")
mass_VT <- readRDS(file = "Nepal_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "Nepal_ggCaller_PopPUNK"
dt <- 1/12
peripost_mass_cluster_freq <- data.frame("year" = 1:13, rbind(mass_cluster_freq_2, mass_cluster_freq_3, mass_cluster_freq_4, mass_cluster_freq_5, mass_cluster_freq_6, mass_cluster_freq_7, mass_cluster_freq_8, mass_cluster_freq_9,mass_cluster_freq_10, mass_cluster_freq_11, mass_cluster_freq_12, mass_cluster_freq_13,mass_cluster_freq_14))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec, pmcmc_sigma_w)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)],
sigma_w = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1 + 1)]), as.list(theta))
}
}
transform <- function() {
make_transform(complex_params)}
transformed_params <- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function() {
make_transform(complex_params)}
transformed_params <- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model4params.R")
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model4params.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
# Using MCMC to infer parameters
#pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
#pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function() {
make_transform(complex_params)}
transformed_params <- make_transform(complex_params)
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
results_path_6_5 <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_06_05_2/"
Nepal_2ndfit <- readRDS(paste(results_path_24,"Nepal_ggCaller_PopPUNK_stoch_pmcmc_run2.rds",sep = ""))
results_path_6_5 <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_06_05_2/"
Nepal_2ndfit <- readRDS(paste(results_path_24,"Nepal_ggCaller_PopPUNK_stoch_pmcmc_run2.rds",sep = ""))
Nepal_2ndfit <- readRDS(paste(results_path_6_5,"Nepal_ggCaller_PopPUNK_stoch_pmcmc_run2.rds",sep = ""))
Nepal_mcmc2 <- coda::as.mcmc(cbind(Nepal_2ndfit$probabilities, Nepal_2ndfit$pars))
coda::effectiveSize(Nepal_mcmc2)
summary(coda::as.mcmc(Nepal_mcmc2))
processed_chains <- mcstate::pmcmc_thin(Nepal_2ndfit, burnin = 100, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
print("det_mcmc_2 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
det_proposal_matrix
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[2], min = 0, max = 1),mcstate::pmcmc_parameter("m", parameter_mean_hpd[3], min = -1000, max = 0), mcstate::pmcmc_parameter("v", parameter_mean_hpd[4], min = 0, max = 1)), det_proposal_matrix, transformed_params)
filter <- mcstate::particle_filter$new(data = fitting_mass_data,
model = WF,
n_particles = 96,
compare = combined_compare,
n_threads = 1)
n_steps <- 1000
n_burnin <- 0
n_steps <- 10
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 2)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 1)
stoch_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, filter, control = control)
### Reading in the Accession Codes, Population and the Sequence Clusters
library(readxl)
Samples_accCodes <- read_excel(paste(path_to_data, "Massachusetts_data_NickCroucher/SupplementaryDataPaper/Samples_accCodes.xlsx", sep = ""))
View(Samples_accCodes)
library(readxl)
Navajo_meta_data <- read_excel(paste(path_to_data, "StrepPneumo_Navajo/metadata.xlsx", sep = ""))
Navajo_meta_data <- read_excel(paste(path_to_data, "StrepPneumo_Navajo/metadata.xlsx", sep = ""))
View(Navajo_meta_data)
Navajo_time_points <- sort(unique(Navajo_meta_data$Year))
Navajo_time_points
Navajo_SeqYear_dict <- Navajo_meta_data$Year
names(Navajo_SeqYear_dict) <- Navajo_meta_data$Lane_id
names(Navajo_SeqYear_dict) <- Navajo_meta_data$Accession
Navajo_meta_IDtoInd <- 1:nrow(Navajo_meta_data)
names(Navajo_meta_IDtoInd) <- Navajo_meta_data$Accession
length(Navajo_meta_IDtoInd)
seq_no_per_year <- rep(0, length(Navajo_time_points))
names(seq_no_per_year) <- Navajo_time_points
for (i in 1:length(Navajo_time_points)) {
seq_no_per_year[i] <- length(which(Navajo_meta_data$Year==Navajo_time_points[i]))
}
barplot(seq_no_per_year, xlab = "Sequencing Years", ylim = c(0, 250), ylab = "Sequence Counts")
barplot(seq_no_per_year, xlab = "Sequencing Years", ylab = "Sequence Counts")
Navajo_time_seq <- Navajo_time_points[1]:Navajo_time_points[length(Navajo_time_points)]
Navajo_time_seq
seq_no_per_year <- rep(0, length(Navajo_time_seq))
names(seq_no_per_year) <- Navajo_time_seq
for (i in 1:length(Navajo_time_seq)) {
seq_no_per_year[i] <- length(which(Navajo_meta_data$Year==Navajo_time_seq[i]))
}
barplot(seq_no_per_year, xlab = "Sequencing Years", ylab = "Sequence Counts")
Nepal_time_points[1:10]
# PCV7 was introduced in 2000
# PCV13 was introduced in 2010
# according to Azarian et al. (2018) https://doi.org/10.1371/journal.ppat.1006966
#
Navajo_time_points_selected <- Navajo_time_seq
Navajo_time_points_preVac1 <- Navajo_time_seq[1:3]
Navajo_time_points_preVac2 <- Navajo_time_seq[4:13]
Navajo_time_points_preVac1
Navajo_time_points_preVac2
Navajo_time_points_preVac2 <- Navajo_time_seq[1:13]
results_path_6_6 <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_06_06/run2"
Nepal_2ndfit <- readRDS(paste(results_path_6_6,"Nepal_ggCaller_PopPUNK_stoch_pmcmc_run2.rds",sep = ""))
results_path_6_6 <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_06_06/run2/"
Nepal_2ndfit <- readRDS(paste(results_path_6_6,"Nepal_ggCaller_PopPUNK_stoch_pmcmc_run2.rds",sep = ""))
Nepal_mcmc2 <- coda::as.mcmc(cbind(Nepal_2ndfit$probabilities, Nepal_2ndfit$pars))
coda::effectiveSize(Nepal_mcmc2)
summary(coda::as.mcmc(Nepal_mcmc2))
192 * 2
Nepal_PP <- read.csv(paste(path_to_data, "StrepPneumo_Navajo/poppunk_clusters/poppunk_clusters_clusters.csv",sep = ""))
Navajo_PP <- read.csv(paste(path_to_data, "StrepPneumo_Navajo/poppunk_clusters/poppunk_clusters_clusters.csv",sep = ""))
no_Navajo_PP <- length(unique(Navajo_PP$Cluster)) # 212 clusters!
no_Navajo_PP
Nepal_PP <- read.csv(paste(path_to_data, "StrepPneumo_Nepal/PopPUNKwithStandardDB/poppunk_clusters_clusters.csv",sep = ""))
no_Nepal_PP <- length(unique(Nepal_PP$Cluster)) # 212 clusters!
no_Nepal_PP
View(Nepal_PP)
length((Nepal_PP$Cluster))
dim(Nepal_meta_data)
length((Navajo_PP$Cluster))
length(unique(Nepal_PP$Cluster))
Navajo_PP <- read.csv(paste(path_to_data, "StrepPneumo_Navajo/poppunk_clusters/poppunk_clusters_clusters.csv",sep = ""))
no_Navajo_PP <- length(unique(Navajo_PP$Cluster)) #  57 clusters!
Navajo_seq_clusters_dict <- Navajo_PP$Cluster
names(Navajo_seq_clusters_dict) <- Navajo_PP$Taxon
Navajo_seq_clusters_dict
Nepal_PP <- read.csv(paste(path_to_data, "StrepPneumo_Nepal/PopPUNKwithStandardDB/poppunk_clusters_clusters.csv",sep = ""))
no_Nepal_PP <- length(unique(Nepal_PP$Cluster)) # 212 clusters!
no_Nepal_PP
View(Nepal_meta_data)
View(Nepal_PP)
PP_all <- read.csv(paste(path_to_data, "StrepPneumo_Nepal/PopPUNKwithStandardDB/poppunk_clusters_clusters.csv",sep = ""))
# since Nepal was in the database, I had to run PopPUNK with --write-references
# so now I need to filter this dataset to only have the real Nepal sequences
PP_taxon_ind_dict <- 1:nrow(PP_all)
names(PP_taxon_ind_dict) <- PP_all$Taxon
PP_is_Nepal_dict <- rep(FALSE,nrow(PP_all))
names(PP_is_Nepal_dict) <- PP_all$Taxon
Nepal_meta_data$Lane_id[1]
for (i in 1:length(Nepal_meta_data$Lane_id)) {
PP_is_Nepal_dict[Nepal_meta_data$Lane_id[i]] <- TRUE
}
PP_is_Nepal_dict
Nepal_PP <- PP_all[PP_is_Nepal_dict,]
View(Nepal_PP)
no_Nepal_PP <- length(unique(Nepal_PP$Cluster)) # 212 clusters!
no_Nepal_PP
length(Nepal_meta_data$Lane_id)
old_Nepal_PP <- readRDS("Nepal_meta_dataPP.rds")
View(old_Nepal_PP)
old_Nepal_PP <- readRDS("Nepal_PP.rds")
View(old_Nepal_PP)
no_Nepal_PP <- length(unique(old_Nepal_PP$Cluster))
no_Nepal_PP
length((old_Nepal_PP$Cluster))
length((Nepal_PP$Cluster))
# Construct an object with two parameters:
pars <- mcstate::pmcmc_parameters$new(
list(mcstate::pmcmc_parameter("a", 0.1, min = 0, max = 1,
prior = function(a) log(a)),
mcstate::pmcmc_parameter("b", 0, prior = dnorm)),
matrix(c(1, 0.5, 0.5, 2), 2, 2))
# Initial parameters
p <- pars$initial()
p
# Propose a new parameter point
pars$propose(p)
# Information about parameters:
pars$names()
#> [1] "a" "b"
pars$summary()
# Compute prior
pars$prior(p)
# Transform data for your model
pars$model(p)
# Above we describe a nontrivial transformation function using a closure
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
# Suppose this is our demographic matrix (note here that the name
# need not match that used in the transform)
demographic_matrix <- diag(4)
# Construct the parameters as above, but this time passing in the
# function that make_transform returns
pars <- mcstate::pmcmc_parameters$new(
list(mcstate::pmcmc_parameter("a", 0.1, min = 0, max = 1,
prior = function(a) log(a)),
mcstate::pmcmc_parameter("b", 0, prior = dnorm)),
matrix(c(1, 0.5, 0.5, 2), 2, 2),
make_transform(demographic_matrix))
# Now, as above we start from a position in terms of a and b only:
pars$initial()
# But when prepared for the model, our matrix will be set up
pars$model(pars$initial())
gen_sir <- dust::dust_example("sir")
gen_sir
seq(1,40,4)
length(seq(1,40,4))
incidence <- data.frame(as.matrix(cbind(1:10, seq(1,40,4))))
View(incidence)
dt <- 0.25
sir_data <- mcstate::particle_filter_data(data = incidence,
time = "day",
rate = 1 / dt)
colnames(incidence) <- c("day","cases")
dt <- 0.25
sir_data <- mcstate::particle_filter_data(data = incidence,
time = "day",
rate = 1 / dt)
dt <- 0.25
dt <- 0.25
sir_data <- mcstate::particle_filter_data(data = incidence,
time = "day",
initial_time = 1,
rate = 1 / dt)
sir_data
sir_data <- mcstate::particle_filter_data(data = incidence,
time = "day",
initial_time = 0,
rate = 1 / dt)
sir_data
case_compare <- function(state, observed, pars = NULL) {
exp_noise <- 1e6
incidence_modelled <- state[5, , drop = TRUE]
incidence_observed <- observed$cases
lambda <- incidence_modelled +
rexp(n = length(incidence_modelled), rate = exp_noise)
dpois(x = incidence_observed, lambda = lambda, log = TRUE)
}
gen_sir$new(pars = list(), time = 0, n_particles = 1L)$info()
n_particles <- 10
filter <- mcstate::particle_filter$new(data = sir_data,
model = gen_sir,
n_particles = n_particles,
compare = case_compare,
seed = 1L)
filter$run(save_history = TRUE, pars = list(dt = dt))
beta <- mcstate::pmcmc_parameter("beta", 0.2, min = 0)
proposal_matrix <- diag(0.1,1)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(beta = beta, gamma = gamma),
proposal_matrix)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(beta = beta),
proposal_matrix)
pars$initial()
mcmc_pars$initial()
# Above we describe a nontrivial transformation function using a closure
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
gamma <- 2
pars <- mcstate::pmcmc_parameters$new(
pars <- mcstate::pmcmc_parameters$new( list(beta, proposal_matrix, make_transform(gamma))
)
)
gamma <- 2
pars <- mcstate::pmcmc_parameters$new( list(beta, proposal_matrix, make_transform(gamma))
)
pars <- mcstate::pmcmc_parameters$new( list(beta), proposal_matrix, make_transform(gamma)))
pars <- mcstate::pmcmc_parameters$new( list(beta), proposal_matrix, make_transform(gamma))
pars
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
n_steps <- 50
n_burnin <- 20
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
pmcmc_run
plot_particle_filter(pmcmc_run$trajectories$state, true_history, incidence$day)
pmcmc_run$trajectories$state,
pmcmc_run$trajectories$state
