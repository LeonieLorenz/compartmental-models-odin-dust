ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_L <- mcstate::pmcmc_parameter("L", 0.15, min = 0, max = 1)
pmcmc_Y <- mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 1)
pmcmc_x0 <- mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("Y", 0.02, min = 0, max = 1), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print("det_mcmc_1 log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", parameter_mean_hpd[1], min = 0, max = 1), mcstate::pmcmc_parameter("Y", parameter_mean_hpd[2], min = 0, max = 1), mcstate::pmcmc_parameter("x0", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 20000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_additiveSigma.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
print("det_mcmc_1 log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 20000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
# sigma_f, sigma_w step function and possible logistic functions to mimic the values
plot(c(rep(0.0006039627, 1774 * (1-0.3669067334)), rep(0.1789665082, 1774 * 0.3669067334)))
lines(0.1789665082/(1 + exp(- 0.2 * (1:1774 - 1774*(1-0.3669067334)))))
# so there is just 1 element that has an intermediate value.
# question: do I need the steepness value then?
# is there a similar function that does not need the steepness parameter?
# there is a different definition of the logistic function, which is 1/(1 + exp(-x)), I could use that as 1/(1 + exp(- 1 *(x - x0)) or 1/(1 + exp(x0 - x))
plot(1/(1+exp((1774*(0.62342733)-1:1774))))
line(c(rep(0.0006039627, 1774 * (1-0.3669067334)), rep(0.1789665082, 1774 * 0.3669067334)))
lines(c(rep(0.0006039627, 1774 * (1-0.3669067334)), rep(0.1789665082, 1774 * 0.3669067334)))
# comparison ggC + manSeqCl for step function and logistic function
lines(0.309057542/(1 + exp(- 4.681828437 * (1:1774 - 1774*(0.809096221)))))
lines(c(rep(0.0003669121 , 1774 * (1-0.2161135322)), rep(0.1882242231 , 1774 * 0.2161135322)))
# comparison ggC + manSeqCl for step function and logistic function
plot(0.309057542/(1 + exp(- 4.681828437 * (1:1774 - 1774*(0.809096221)))))
lines(c(rep(0.0003669121 , 1774 * (1-0.2161135322)), rep(0.1882242231 , 1774 * 0.2161135322)))
# comparison ggC + PP for step function and logistic function
plot(0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733)))))
lines(c(rep(0.0004164005 , 1774 * (1-0.3803173188)), rep(0.1180783495 , 1774 * 0.3803173188)))
# comparison ggC + PP for step function and logistic function
plot(0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733)))), ylim = c(0, 0.12))
lines(c(rep(0.0004164005 , 1774 * (1-0.3803173188)), rep(0.1180783495 , 1774 * 0.3803173188)))
# comparison ggC + PP for step function and logistic function
plot(0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733)))), ylim = c(0, 0.12), main = "Comparison ggCPP for step function and logistic function NFDS")
lines(c(rep(0.0004164005 , 1774 * (1-0.3803173188)), rep(0.1180783495 , 1774 * 0.3803173188)), col = "red")
legend(0, 0.3, legend=c("logistic function", "step function"),
col=c("black", "red"), lty=1, cex=0.8)
# comparison ggC + PP for step function and logistic function
plot(0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733)))), ylim = c(0, 0.12), main = "Comparison ggCPP for step function and logistic function NFDS", xlab = "Genes", ylab = "Selection Strength")
lines(c(rep(0.0004164005 , 1774 * (1-0.3803173188)), rep(0.1180783495 , 1774 * 0.3803173188)), col = "red")
legend(0, 0.3, legend=c("logistic function", "step function"),
col=c("black", "red"), lty=1, cex=0.8)
legend(0, 0.1, legend=c("logistic function", "step function"),
col=c("black", "red"), lty=1, cex=0.8)
dim(intermed_gene_presence_absence_consensus)
dim(ggC_intermed_gene_presence_absence_consensus)
Mass_Samples_accCodes <- readRDS(file = "Mass_Samples_accCodes.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "intermed_gene_presence_absence_consensus.rds")
dim(intermed_gene_presence_absence_consensus)
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
## command line arguments
args <- commandArgs(trailingOnly = TRUE)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "4param_ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- 0
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec, pmcmc_sigma_w)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)],
sigma_w = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1 + 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
coda::effectiveSize(det_mcmc1)
saveRDS(det_mcmc1,"det_mcmc1_4params_ggCPP.rds")
saved_det_mcmc1 <- readRDS("det_mcmc1_4params_ggCPP.rds")
summary(saved_det_mcmc1)
coda::effectiveSize(saved_det_mcmc1)
paste(output_filename, "_det_mcmc2.rds", sep = "")
setwd("/Users/llorenz/Documents/PhD_Project/Code/1st_project/odin-dust-examples/WrightFisherModel_2024")
# path to results:
results_path <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_04_15"
# path to results:
results_path <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_04_15/"
# saved_det_mcmc2 <- readRDS(paste(results_path, "xxx.rds",sep=""))
# coda::effectiveSize(saved_det_mcmc2)
COGmanSeqCl_det_mcmc2 <- readRDS(paste(results_path, "COGtriangles_manSeqClusters_det_mcmc2.rds",sep=""))
coda::effectiveSize(COGmanSeqCl_det_mcmc2)
summary(COGmanSeqCl_det_mcmc2)
# effective sample size differs a lot between the parameters!
1 - coda::rejectionRate(COGmanSeqCl_det_mcmc2)
gelman.plot(COGmanSeqCl_det_mcmc2)
COGmanSeqCl_det_mcmc2
combinedchains = mcmc.list(COGmanSeqCl_det_mcmc2[1:1000,], COGmanSeqCl_det_mcmc2[1001:2000,])
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[1001:2000,]))
gelman.plot(combinedchains)
summary(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,]))
COGmanSeqCl_det_mcmc2[1:1000,]
plot(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,]))
coda::plot(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,]))
plot(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,]))
gelman.plot(combinedchains)
plot(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,-1:3]))
(COGmanSeqCl_det_mcmc2[1:1000,-1:3]))
(COGmanSeqCl_det_mcmc2[1:1000,-1:3])
(COGmanSeqCl_det_mcmc2[1:1000,-(1:3)])
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[1001:2000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:1000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[1001:2000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[2001:3000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[3001:4000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:2000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[2001:4000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[4001:6000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[6001:8000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1001:2000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[3001:4000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[5001:6000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[7001:8000,-(1:3)]))
gelman.plot(combinedchains)
COGPP_det_mcmc2 <- readRDS(paste(results_path, "COGtriangles_PopPUNK_det_mcmc2.rds",sep=""))
coda::effectiveSize(COGPP_det_mcmc2)
# much better effective sample size!
1 - coda::rejectionRate(COGPP_det_mcmc2)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1:2000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[2001:4000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[4001:6000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[6001:8000,-(1:3)]))
gelman.plot(combinedchains)
dim(COGPP_det_mcmc2)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[20001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[40001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[60001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1:20000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[20001:40000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[40001:60000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[60001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[5001:20000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[25001:40000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[45001:60000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[65001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[20001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[40001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[60001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[5001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[25001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[45001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[65001:80000,-(1:3)]))
gelman.plot(combinedchains)
parameter_mean_hpd <- apply(COGPP_det_mcmc2[,-(1:3)], 2, mean)
parameter_mean_hpd
parameter_mean_hpd <- apply(COGmanSeqCl_det_mcmc2[,-(1:3)], 2, mean)
parameter_mean_hpd
parameter_mean_hpd <- apply(COGmanSeqCl_det_mcmc2[5001:20000,-(1:3)], 2, mean)
parameter_mean_hpd
parameter_mean_hpd <- apply(COGmanSeqCl_det_mcmc2[c(5001:20000,25001:40000,45001:60000,65001:80000),-(1:3)], 2, mean)
parameter_mean_hpd
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[10001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[30001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[50001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[70001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[12001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[32001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[52001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[72001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[14001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[34001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[54001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[74001:80000,-(1:3)]))
gelman.plot(combinedchains)
parameter_mean_hpd <- apply(COGPP_det_mcmc2[,-(1:3)], 2, mean)
parameter_mean_hpd
parameter_mean_hpd <- apply(COGPP_det_mcmc2[c(14001:20000, 34001:40000, 54001:60000, 74001:80000),-(1:3)], 2, mean)
parameter_mean_hpd
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
thin(combinedchains)
coda::mcmc(combinedchains, thin = 2)
COGPP_det_mcmc2_thineed <- coda::mcmc(COGPP_det_mcmc2, thin = 2)
COGPP_det_mcmc2_thinned <- coda::mcmc(COGPP_det_mcmc2, thin = 2)
parameter_mean_hpd <- apply(COGPP_det_mcmc2_thinned[,-(1:3)], 2, mean)
parameter_mean_hpd
parameter_mean_hpd <- apply(COGPP_det_mcmc2[,-(1:3)], 2, mean)
parameter_mean_hpd
ggCmanSeqCl_det_mcmc2 <- readRDS(paste(results_path, "ggCaller_manSeqClusters_det_mcmc2.rds",sep=""))
coda::effectiveSize(ggCmanSeqCl_det_mcmc2)
# effective sample size better than COGmanSeqCl but could be better
1 - coda::rejectionRate(ggCmanSeqCl_det_mcmc2)
combinedchains = mcmc.list(coda::as.mcmc(ggCmanSeqCl_det_mcmc2[1:20000,-(1:3)]), coda::as.mcmc(ggCmanSeqCl_det_mcmc2[20001:40000,-(1:3)]),coda::as.mcmc(ggCmanSeqCl_det_mcmc2[40001:60000,-(1:3)]),coda::as.mcmc(ggCmanSeqCl_det_mcmc2[60001:80000,-(1:3)]))
gelman.plot(combinedchains)
parameter_mean_hpd <- apply(ggCmanSeqCl_det_mcmc2[,-(1:3)], 2, mean)
parameter_mean_hpd
combinedchains = mcmc.list(coda::as.mcmc(COGmanSeqCl_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGmanSeqCl_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGmanSeqCl_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
View(control)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(ggCmanSeqCl_det_mcmc2[1:20000,-(1:3)]), coda::as.mcmc(ggCmanSeqCl_det_mcmc2[20001:40000,-(1:3)]),coda::as.mcmc(ggCmanSeqCl_det_mcmc2[40001:60000,-(1:3)]),coda::as.mcmc(ggCmanSeqCl_det_mcmc2[60001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(ggCmanSeqCl_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(ggCmanSeqCl_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(ggCmanSeqCl_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(ggCmanSeqCl_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
combinedchains = mcmc.list(coda::as.mcmc(COGPP_det_mcmc2[1001:20000,-(1:3)]), coda::as.mcmc(COGPP_det_mcmc2[21001:40000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[41001:60000,-(1:3)]),coda::as.mcmc(COGPP_det_mcmc2[61001:80000,-(1:3)]))
gelman.plot(combinedchains)
