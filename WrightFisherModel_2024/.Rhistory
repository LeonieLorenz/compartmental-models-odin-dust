#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
delta_ranking
gene_no
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
## command line arguments
args <- commandArgs(trailingOnly = TRUE)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state[2:mass_clusters+1, , drop = TRUE]))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
sero_no = length(unique(seq_clusters$Serotype))
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PPsero_startpop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "SeroVT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- readRDS(file = "PPsero_mig.rds")
output_filename <- "PPxSero_ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec, pmcmc_sigma_w, sero_no)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = matrix(p[1:(nrow(Pop_ini) * ncol(Pop_ini))], nrow = mass_clusters, ncol = sero_no),
Pop_eq = p[((nrow(Pop_ini) * ncol(Pop_ini)) +1) : ((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq))],
Genotypes = matrix(p[(((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq))+ 1): (((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes))], nrow = gene_no, ncol = species_no),
capacity = p[(((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 1],
delta = p[((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2) : ((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no -1)],
vaccTypes = p[((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) : (((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no -1)],
species_no = p[(((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no )],
gene_no = p[(((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no)+ 1],
vacc_time = p[(((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no) + 2],
dt = p[(((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no) + 3],
migVec = matrix(p[((((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no) + 4):((((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no) + 4 + (nrow(migVec) * ncol(migVec)) -1)], nrow = mass_clusters, ncol = sero_no),
sigma_w = p[((((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no) + 4 + (nrow(migVec) * ncol(migVec)))],
sero_no = p[((((((nrow(Pop_ini) * ncol(Pop_ini)) + length(Pop_eq)) + nrow(Genotypes) * ncol(Genotypes)) + 2 + gene_no) + sero_no) + 4 + (nrow(migVec) * ncol(migVec)) +1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
proposal_matrix[1,1] <- exp(0.1)
proposal_matrix[3,3] <- exp(0.1)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
length(ggC_delta_ranking.rds)
length(delta_ranking)
n_steps <- 100
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
# path to results:
results_path_22 <- "/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_05_22/"
ga_results <- readRDS(paste(results_path_22, "FindGenesGA_results.rds",sep = ""))
plot(ga_results)
ga_fit_FindGenes_ggCPP_dec <- fitting_closure_max_decode(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(0, length(best_best_vec)), upper = rep(1,length(best_best_vec)),
seed = 123, elitism = 200, maxiter = 50, popSize = 400, run = 30)
### Likelihood
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(observed)
model_size = sum(state)
for (i in 1:length(observed)){
result <- result + ll_pois(observed[i], state[i]/model_size * data_size)
}
result
}
### load model
WF <- odin.dust::odin_dust("NFDS_Model_FindGenes.R")
decode2 <- function(x)
{
x <- round(x)
return(x)
}
fitting_closure_max_decode <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
fit_params <- decode2(fit_params)
rnd_vect_full <- fit_params
params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
ga_fit_FindGenes_ggCPP_dec <- fitting_closure_max_decode(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(0, length(best_best_vec)), upper = rep(1,length(best_best_vec)),
seed = 123, elitism = 200, maxiter = 50, popSize = 400, run = 30)
summary(gann)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(0, length(best_best_vec)), upper = rep(1,length(best_best_vec)),
seed = 123, elitism = 200, maxiter = 50, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5,)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(0, length(best_best_vec)), upper = rep(1,length(best_best_vec)),
seed = 123, elitism = 200, maxiter = 50, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
plot(gann)
# try optimising the positions that are 1, rather than the 0-1 vector
decode3 <- function(x)
{
x <- round(x)
y <- rep(0, length(best_best_vec))
y[x] <- 1
return(y)
}
fitting_closure_max_decode <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
fit_params <- decode3(fit_params)
rnd_vect_full <- fit_params
params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
ga_fit_FindGenes_ggCPP_dec3 <- fitting_closure_max_decode(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
ga_fit_FindGenes_ggCPP_dec3 <- fitting_closure_max_decode(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(0, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
rep(0, round(0.1*length(best_best_vec)))
rep(length(best_best_vec),round(0.1*length(best_best_vec)))
decode3(rep(length(best_best_vec),round(0.1*length(best_best_vec))))
tail(decode3(rep(length(best_best_vec),round(0.1*length(best_best_vec)))))
y <- rep(0, length(best_best_vec))
y
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
FindGenes_ggCPP_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3090376, sigma_w = 0, prop_f = 1, m = 0.03104461, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.15977862, vacc_time = 0)
fitting_closure_max_decode <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
fit_params <- decode3(fit_params)
rnd_vect_full <- fit_params
params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
fitting_closure_max_decode3 <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
fit_params <- decode3(fit_params)
rnd_vect_full <- fit_params
params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
ga_fit_FindGenes_ggCPP_dec3 <- fitting_closure_max_decode3(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
fitting_closure_max_decode3 <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
fit_params <- decode3(fit_params)
rnd_vect_full <- fit_params
all_other_params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = all_other_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
ga_fit_FindGenes_ggCPP_dec3 <- fitting_closure_max_decode3(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
fitting_closure_max_decode3 <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
rnd_vect_full <- decode3(fit_params)
print(length(rnd_vect_full))
all_other_params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = all_other_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
ga_fit_FindGenes_ggCPP_dec3 <- fitting_closure_max_decode3(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
length(rep(1, round(0.1*length(best_best_vec))))
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
fitting_closure_max_decode3 <- function(all_other_params, data1, data2){
null_fit_dfoptim_fl <- function(fit_params){
rnd_vect_full <- decode3(fit_params)
all_other_params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = all_other_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
#n_particles <- 10L
#n_times <- 73
#x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
#for (t in seq_len(n_times)) {
#  x[ , , t] <- WFmodel_ggCPP$run(t)
#}
#time <- x[1, 1, ]
#x <- x[-1, , ]
simMeanggCPP2 <- rowMeans(WFmodel_ggCPP$run(36)[-1,])
simMeanggCPP3 <- rowMeans(WFmodel_ggCPP$run(72)[-1,])
combined_compare(simMeanggCPP2,data1) + combined_compare(simMeanggCPP3,data2)
#- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
ga_fit_FindGenes_ggCPP_dec3 <- fitting_closure_max_decode3(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 200, maxiter = 5, popSize = 400, run = 5, pcrossover = 0.8, pmutation = 0.5)
plot(gann)
summary(gann)
as.vector(t(apply(gann@solution, 1, decode3)))
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 50, maxiter = 5, popSize = 500, run = 5, pcrossover = 0.8, pmutation = 0.5)
plot(gann)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 50, maxiter = 5, popSize = 500, run = 5, pcrossover = 0.8, pmutation = 0.1)
plot(gann)
summary(gann)
gareal_raMutation(gann,rep(1, round(0.1*length(best_best_vec))))
gareal_raMutation(gann,10)
gann
gareal_raMutation(gann,1)
gann@solution
gareal_raMutation(gann,1)
gareal_raMutation(gann,1)
gareal_raMutation(gann,2)
gareal_raMutation(gann,177)
gareal_raMutation
gareal_raMutation_R
gareal_raMutation_R()
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 50, maxiter = 5, popSize = 500, run = 5, pcrossover = 0.8, pmutation = 0.1, mutation = gareal_powMutation)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 50, maxiter = 20, popSize = 300, run = 5, pcrossover = 0.8, pmutation = 0.3, mutation = gareal_powMutation)
gann <- ga(type = "real-valued", fitness = ga_fit_FindGenes_ggCPP_dec3, lower = rep(1, round(0.1*length(best_best_vec))), upper = rep(length(best_best_vec),round(0.1*length(best_best_vec))),
seed = 123, elitism = 50, maxiter = 20, popSize = 300, run = 20, pcrossover = 0.8, pmutation = 0.3, mutation = gareal_powMutation)
gann@population
plot(gann@population)
# implement my own mutation function?
# this is the implementation of
# gareal_raMutation_R <- function(object, parent)
#{
#  mutate <- parent <- as.vector(object@population[parent,])
#  n <- length(parent)
#  j <- sample(1:n, size = 1)
#  mutate[j] <- runif(1, object@lower[j], object@upper[j])
#  return(mutate)
#}
plot(1:177,gann@population)
# implement my own mutation function?
# this is the implementation of
# gareal_raMutation_R <- function(object, parent)
#{
#  mutate <- parent <- as.vector(object@population[parent,])
#  n <- length(parent)
#  j <- sample(1:n, size = 1)
#  mutate[j] <- runif(1, object@lower[j], object@upper[j])
#  return(mutate)
#}
plot(1:177,gann@population[1,])
# implement my own mutation function?
# this is the implementation of
# gareal_raMutation_R <- function(object, parent)
#{
#  mutate <- parent <- as.vector(object@population[parent,])
#  n <- length(parent)
#  j <- sample(1:n, size = 1)
#  mutate[j] <- runif(1, object@lower[j], object@upper[j])
#  return(mutate)
#}
plot(1:177,gann@population[1:300,])
# implement my own mutation function?
# this is the implementation of
# gareal_raMutation_R <- function(object, parent)
#{
#  mutate <- parent <- as.vector(object@population[parent,])
#  n <- length(parent)
#  j <- sample(1:n, size = 1)
#  mutate[j] <- runif(1, object@lower[j], object@upper[j])
#  return(mutate)
#}
plot(1:177,sort(gann@population[1:300,]))
# implement my own mutation function?
# this is the implementation of
# gareal_raMutation_R <- function(object, parent)
#{
#  mutate <- parent <- as.vector(object@population[parent,])
#  n <- length(parent)
#  j <- sample(1:n, size = 1)
#  mutate[j] <- runif(1, object@lower[j], object@upper[j])
#  return(mutate)
#}
plot(1:177,sort(gann@population[1,]))
points(sort(gann@population[2,]))
points(sort(gann@population[3,]))
# implement my own mutation function?
# this is the implementation of
# gareal_raMutation_R <- function(object, parent)
#{
#  mutate <- parent <- as.vector(object@population[parent,])
#  n <- length(parent)
#  j <- sample(1:n, size = 1)
#  mutate[j] <- runif(1, object@lower[j], object@upper[j])
#  return(mutate)
#}
plot(1:177,sort(gann@population[1,]))
points(sort(gann@population[2,]))
points(sort(gann@population[3,]))
plot(1:1774,as.vector(t(apply((gann@population[1,]), 1, decode3))))
plot(1:1774,as.vector(t(apply((gann@population), 1, decode3))))
plot(1:1774,as.vector(t(apply((gann@population), 2, decode3))))
gann@solution
decode3(gann@population[1,])
plot(1:1774,decode3(gann@population[1,]))
apply((gann@population), 1, decode3))
apply((gann@population), 1, decode3)
apply((gann@population), 2, decode3)
apply((gann@population), 1, decode3)
rowSums(apply((gann@population), 1, decode3))
plot(1:1774,colSums(apply((gann@population), 1, decode3)))
plot(1:1774,rowSums(apply((gann@population), 1, decode3)))
