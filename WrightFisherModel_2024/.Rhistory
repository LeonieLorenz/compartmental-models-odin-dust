time <- x[1, 1, ]
x <- x[-1, , ]
combined_compare(x[,1,37],data1) + combined_compare(x[,1,73],data2)
}
}
FindGenes_ggCPP_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3090376, sigma_w = 0, prop_f = 1, m = 0.03104461, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.15977862, vacc_time = 0)
fit_FindGenes_ggCPP <- fitting_closure(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
FindGenes_sa <- optim_sa(fun = fit_FindGenes_ggCPP, start = start_vect, maximization = TRUE, trace = TRUE,lower=rep(0,length(start_vect)), upper=rep(1,length(start_vect)))
FindGenes_sa
plot(FindGenes_sa$par)
plot(sort(FindGenes_sa$par))
nextfun <- function(x) sample(-10:10, 2, replace=TRUE)
nextfun(1)
nextfun(2)
nextfun()
nextfun()
nextfun <- function(x) rbinom(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)) ,1,0.1)
nextfun
nextfun()
nextfun()
optim(fn=fitting_closure, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
optim(fn=fit_FindGenes_ggCPP, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
fitting_closure <- function(all_other_params, data1, data2){
null_fit_dfoptim <- function(fit_params){
unique_genes <- setdiff(1:(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1), names(group_gene_cl))
rnd_vect_full <- rep(0, (nrow(ggCPP_intermed_gene_presence_absence_consensus)-1))
rnd_vect_full[unique_genes] <- fit_params
rnd_vect_full[as.integer(names(group_gene_cl))] <- rnd_vect_full[unname(group_gene_cl)]
params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WFmodel_ggCPP$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
nextfun <- function(x) rbinom(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)) ,1,0.1)
optim(fn=fit_FindGenes_ggCPP, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
fitting_closure <- function(all_other_params, data1, data2){
null_fit_dfoptim <- function(fit_params){
unique_genes <- setdiff(1:(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1), names(group_gene_cl))
rnd_vect_full <- rep(0, (nrow(ggCPP_intermed_gene_presence_absence_consensus)-1))
rnd_vect_full[unique_genes] <- fit_params
rnd_vect_full[as.integer(names(group_gene_cl))] <- rnd_vect_full[unname(group_gene_cl)]
params$delta_bool = rnd_vect_full
WFmodel_ggCPP <- WF$new(pars = params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
n_particles <- 10L
n_times <- 73
x <- array(NA, dim = c(WFmodel_ggCPP$info()$len, n_particles, n_times))
for (t in seq_len(n_times)) {
x[ , , t] <- WFmodel_ggCPP$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]
- combined_compare(x[,1,37],data1) - combined_compare(x[,1,73],data2)
}
}
FindGenes_ggCPP_params <- list(dt = 1/36, species_no = PP_mass_clusters,  gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = as.double(PP_model_start_pop), Pop_eq = as.double(PP_model_start_pop), capacity = sum(PP_model_start_pop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = 0.3090376, sigma_w = 0, prop_f = 1, m = 0.03104461, migVec = PP_avg_cluster_freq, vaccTypes = PP_mass_VT, v = 0.15977862, vacc_time = 0)
fit_FindGenes_ggCPP <- fitting_closure(FindGenes_ggCPP_params, PP_mass_cluster_freq_2, PP_mass_cluster_freq_3)
nextfun <- function(x) rbinom(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)) ,1,0.1)
optim(fn=fit_FindGenes_ggCPP, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
runif(1)
nextfun <- function(x) rbinom(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)) ,1,runif(1))
optim(fn=fit_FindGenes_ggCPP, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
$par
par
nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl))
simAnn_results <- data.frame(matrix(0, nrow = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)), ncol = 10))
nextfun <- function(x) rbinom(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)) ,1,runif(1))
FindGenes_sa2 <- optim(fn=fit_FindGenes_ggCPP, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=10,fnscale=1,trace=10))
FindGenes_sa2$value
simAnn_vsalues <- rep(0, 10)
simAnn_values <- rep(0, 10)
nextfun <- function(x) rbinom(nrow(ggCPP_intermed_gene_presence_absence_consensus)-1 -length((group_gene_cl)) ,1,runif(1))
for (i in 1:10) {
FindGenes_sa2 <- optim(fn=fit_FindGenes_ggCPP, par=start_vect, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
simAnn_results[,i] <- FindGenes_sa2$par
simAnn_values[i] <- FindGenes_sa2$value
}
plot(rowMeans(simAnn_results))
plot(simAnn_results[,1])
colMeans(simAnn_results)
plot(simAnn_results[,1])
points(simAnn_results[,2], col = "red")
plot(rowSums(simAnn_results))
length(which(rowSums(simAnn_results)==3))
length(which(rowSums(simAnn_results)==2))
length(which(rowSums(simAnn_results)>=2))
150/1774
which(rowSums(simAnn_results)>=2)
new_start_vec <- rep(0,length(start_vect))
new_start_vec[which(rowSums(simAnn_results)>=2)] <- 1
new_start_vec
fit_FindGenes_ggCPP(new_start_vec)
FindGenes_sa3 <- optim(fn=fit_FindGenes_ggCPP, par=new_start_vec, gr=nextfun, method="SANN",
control=list(maxit=1000,fnscale=1,trace=10))
plot(FindGenes_sa3 + new_start_vec)
plot(FindGenes_sa3$par + new_start_vec)
#sigma_f = 0.1789665082, sigma_w = 0.0006039627, prop_f = 0.3669067334
lines(0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733)))))
#sigma_f = 0.1789665082, sigma_w = 0.0006039627, prop_f = 0.3669067334
plot(0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733)))))
which(0.01 > (0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733))))) < 0.99)
which((0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733))))) < 0.99)
#sigma_f = 0.1789665082, sigma_w = 0.0006039627, prop_f = 0.3669067334
#ggCPP fit results in the following logistic values
ggCPP_log_fit <- 0.11292912/(1 + exp(- 4.95113406 * (1:1774 - 1774*(0.62342733))))
plot(ggCPP_log_fit)
length(which(ggCPP_log_fit[(ggCPP_log_fit)<0.99]>0.01))
length(which(ggCPP_log_fit[which(ggCPP_log_fit<0.99)]>0.01))
length(which(ggCPP_log_fit<0.99))
max(ggCPP_log_fit)
length(which(ggCPP_log_fit[which(ggCPP_log_fit<0.99 * max(ggCPP_log_fit))]>0.01))
plot(1/(1+exp(-1:1774)))
plot(1/(1+exp(-(1:1774))))
plot(1/(1+exp(-(1:1774) - 1774*(0.62342733))))
plot(1/(1+exp((1:1774) - 1774*(0.62342733))))
plot(1/(1+exp(-1 *(1:1774 - 1774*(0.62342733)))))
# so there is just 1 element that has an intermediate value.
# question: do I need the steepness value then?
# is there a similar function that does not need the steepness parameter?
# there is a different definition of the logistic function, which is 1/(1 + exp(-x)), I could use that as 1/(1 + exp(-(x - x0)) or 1/(1 + exp(x0 - x))
plot(1/(1+exp(-1 *(1:1774 - 1774*(0.62342733)))))
# so there is just 1 element that has an intermediate value.
# question: do I need the steepness value then?
# is there a similar function that does not need the steepness parameter?
# there is a different definition of the logistic function, which is 1/(1 + exp(-x)), I could use that as 1/(1 + exp(-(x - x0)) or 1/(1 + exp(x0 - x))
plot(1/(1+exp((1774*(0.62342733)-1:1774))))
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_logistic.R")
# Using MCMC to infer parameters
pmcmc_L <- mcstate::pmcmc_parameter("L", 0.15, min = 0, max = 1)
pmcmc_K <- mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10)
pmcmc_x0 <- mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(0.1, 4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_logistic.R")
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_L <- mcstate::pmcmc_parameter("L", 0.15, min = 0, max = 1)
pmcmc_K <- mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10)
pmcmc_x0 <- mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_inv_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_L <- mcstate::pmcmc_parameter("L", 0.15, min = 0, max = 1)
pmcmc_K <- mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10)
pmcmc_x0 <- mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_logistic.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_inv_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_L <- mcstate::pmcmc_parameter("L", 0.15, min = 0, max = 1)
pmcmc_K <- mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10)
pmcmc_x0 <- mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 0.02, min = 0, max = 10), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("L", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("K", 1, min = 1, max = 1), mcstate::pmcmc_parameter("x0", 0.2, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
