}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
rowSums(migVec)
nrow(PopPUNK_clusters)
PopPUNK_clusters <- readRDS("Navajo_PP.rds")
nrow(PopPUNK_clusters)
dim(PopPUNK_clusters)
PPxSero_matrix_prob2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
dim(PPxSero_matrix_prob2)
PPxSero_matrix_prob2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPxSero_matrix_prob2[i,] <- ((PPxSero_matrix[i,] * Navajo_avg_cluster_freq[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPxSero_matrix_prob2, "Navajo_PPsero_mig.rds")
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="1998")) {
PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
PP_expand_factor <- 15000 / sum(PPsero_startpop)
exp_noise <- 10
#PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
#PPsero_startpop_corr <- matrix(sapply(PPsero_startpop_corr,as.double), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
saveRDS(PPsero_startpop_corr, "PPsero_startpop.rds")
# this lead to a start population that is way too evenly distributed across the different clusters
# instead, I could maybe use the existing PP_model_start_pop and distribute it to the different serotypes?
PPsero_startpop2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPsero_startpop2[i,] <- round((PPxSero_matrix[i,] * Navajo_model_start_pop[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPsero_startpop2, "Navajo_PPsero_startpop.rds")
# serotype VT vector
SeroVT <- rep(0, length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
SeroVT[SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- as.integer(PopPUNK_clusters$VT[i]=="VT")
}
saveRDS(SeroVT, "Navajo_SeroVT.rds")
seq_clusters <- readRDS("Navajo_PP.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "Navajo_ggCaller_intermed_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
delta_ranking <- readRDS(file = "Navajo_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "Navajo_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "Navajo_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "Navajo_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "Navajo_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "Navajo_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "Navajo_cluster_freqs_6.rds")
mass_cluster_freq_7 <- readRDS(file = "Navajo_cluster_freqs_7.rds")
mass_cluster_freq_8 <- readRDS(file = "Navajo_cluster_freqs_8.rds")
mass_cluster_freq_9 <- readRDS(file = "Navajo_cluster_freqs_9.rds")
mass_cluster_freq_10 <- readRDS(file = "Navajo_cluster_freqs_10.rds")
mass_cluster_freq_11 <- readRDS(file = "Navajo_cluster_freqs_11.rds")
mass_cluster_freq_12 <- readRDS(file = "Navajo_cluster_freqs_12.rds")
mass_cluster_freq_13 <- readRDS(file = "Navajo_cluster_freqs_13.rds")
mass_cluster_freq_14 <- readRDS(file = "Navajo_cluster_freqs_14.rds")
mass_cluster_freq_15 <- readRDS(file = "Navajo_cluster_freqs_15.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
sero_no = length(unique(seq_clusters$Serotype))
model_start_pop <- readRDS(file = "Navajo_PPsero_startpop.rds")
mass_VT <- readRDS(file = "Navajo_SeroVT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- readRDS(file = "Navajo_PPsero_mig.rds")
dt <- 1/12
vacc_time <- 2
output_filename <- "Navajo_PPxSero_ggCaller_PopPUNK"
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
proposal_matrix[1,1] <- exp(0.1)
proposal_matrix[3,3] <- exp(0.1)
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
PopPUNK_clusters <- readRDS("UK_PP.rds")
UK_model_start_pop <- readRDS("UK_model_start_pop.rds")
UK_model_start_pop
mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
Navajo_avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
PopPUNK_clusters <- readRDS("UK_PP.rds")
UK_model_start_pop <- readRDS("UK_model_start_pop.rds")
mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
UK_avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
PPxSero_matrix <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
SerotypeToIndex_dict <- 1:length(unique(PopPUNK_clusters$Serotype))
names(SerotypeToIndex_dict) <- sort(unique(PopPUNK_clusters$Serotype))
IndexToSerotype_dict <- sort(unique(PopPUNK_clusters$Serotype))
names(IndexToSerotype_dict) <- 1:length(unique(PopPUNK_clusters$Serotype))
PPclustToIndex_dict <- 1:length(unique(PopPUNK_clusters$Cluster))
names(PPclustToIndex_dict) <- sort(unique(PopPUNK_clusters$Cluster))
for (i in 1:nrow(PopPUNK_clusters)) {
PPxSero_matrix[PPclustToIndex_dict[as.character(PopPUNK_clusters$Cluster[i])],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
PPxSero_matrix_prob2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPxSero_matrix_prob2[i,] <- ((PPxSero_matrix[i,] * UK_avg_cluster_freq[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPxSero_matrix_prob2, "Navajo_PPsero_mig.rds")
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="1998")) {
PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
PopPUNK_clusters <- readRDS("UK_PP.rds")
UK_model_start_pop <- readRDS("UK_model_start_pop.rds")
mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
UK_avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
PPxSero_matrix <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
# sort(unique(PopPUNK_clusters$Serotype))
# [1] "10A"   "11A"   "14"    "15A"   "15B/C" "15F"   "16F"   "17F"   "18C"   "19A"   "19F"   "21"    "22F"   "23A"
#[15] "23B"   "23F"   "3"     "31"    "33F"   "34"    "35B"   "35F"   "37"    "38"    "6A"    "6B"    "6C"    "7C"
#[29] "7F"    "9N"    "9V"    "NT"
SerotypeToIndex_dict <- 1:length(unique(PopPUNK_clusters$Serotype))
names(SerotypeToIndex_dict) <- sort(unique(PopPUNK_clusters$Serotype))
IndexToSerotype_dict <- sort(unique(PopPUNK_clusters$Serotype))
names(IndexToSerotype_dict) <- 1:length(unique(PopPUNK_clusters$Serotype))
PPclustToIndex_dict <- 1:length(unique(PopPUNK_clusters$Cluster))
names(PPclustToIndex_dict) <- sort(unique(PopPUNK_clusters$Cluster))
for (i in 1:nrow(PopPUNK_clusters)) {
PPxSero_matrix[PPclustToIndex_dict[as.character(PopPUNK_clusters$Cluster[i])],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
# matrix shows information whether PP and serotype co-occur in the dataset (1=TRUE)
# this can be used as the migration matrix:
#PPxSero_matrix_prob <- PPxSero_matrix / sum(PPxSero_matrix)
#PPxSero_matrix_prob <- matrix(sapply(PPxSero_matrix_prob,as.double), nrow = nrow(PPxSero_matrix), ncol = ncol(PPxSero_matrix))
#saveRDS(PPxSero_matrix_prob, "Navajo_PPsero_mig.rds")
PPxSero_matrix_prob2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPxSero_matrix_prob2[i,] <- ((PPxSero_matrix[i,] * UK_avg_cluster_freq[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPxSero_matrix_prob2, "UK_PPsero_mig.rds")
# new migration matrix that is closer to original one
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="1998")) {
PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
#PPsero_startpop <- PPsero_startpop * 15000 / sum(PPsero_startpop)
PP_expand_factor <- 15000 / sum(PPsero_startpop)
exp_noise <- 10
#PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
#PPsero_startpop_corr <- matrix(sapply(PPsero_startpop_corr,as.double), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
#saveRDS(PPsero_startpop_corr, "PPsero_startpop.rds")
# this lead to a start population that is way too evenly distributed across the different clusters
# instead, I could maybe use the existing PP_model_start_pop and distribute it to the different serotypes?
PPsero_startpop2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPsero_startpop2[i,] <- round((PPxSero_matrix[i,] * UK_model_start_pop[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPsero_startpop2, "UK_PPsero_startpop.rds")
# this is very close to the original PP_model_start_pop
# maybe I am giving out too much information because the serotype distribution is exactly the real one?
# serotype VT vector
SeroVT <- rep(0, length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
SeroVT[SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- as.integer(PopPUNK_clusters$VT[i]=="VT")
}
# serotype VT vector
SeroVT <- rep(0, length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
SeroVT[SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- as.integer(PopPUNK_clusters$VT_PCV7[i]=="VT")
}
saveRDS(SeroVT, "UK_SeroVT.rds")
PopPUNK_clusters <- readRDS("Navajo_PP.rds")
Navajo_model_start_pop <- readRDS("Navajo_model_start_pop.rds")
mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
Navajo_avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
PPxSero_matrix <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
# sort(unique(PopPUNK_clusters$Serotype))
# [1] "10A"   "11A"   "14"    "15A"   "15B/C" "15F"   "16F"   "17F"   "18C"   "19A"   "19F"   "21"    "22F"   "23A"
#[15] "23B"   "23F"   "3"     "31"    "33F"   "34"    "35B"   "35F"   "37"    "38"    "6A"    "6B"    "6C"    "7C"
#[29] "7F"    "9N"    "9V"    "NT"
SerotypeToIndex_dict <- 1:length(unique(PopPUNK_clusters$Serotype))
names(SerotypeToIndex_dict) <- sort(unique(PopPUNK_clusters$Serotype))
IndexToSerotype_dict <- sort(unique(PopPUNK_clusters$Serotype))
names(IndexToSerotype_dict) <- 1:length(unique(PopPUNK_clusters$Serotype))
PPclustToIndex_dict <- 1:length(unique(PopPUNK_clusters$Cluster))
names(PPclustToIndex_dict) <- sort(unique(PopPUNK_clusters$Cluster))
for (i in 1:nrow(PopPUNK_clusters)) {
PPxSero_matrix[PPclustToIndex_dict[as.character(PopPUNK_clusters$Cluster[i])],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
# matrix shows information whether PP and serotype co-occur in the dataset (1=TRUE)
# this can be used as the migration matrix:
#PPxSero_matrix_prob <- PPxSero_matrix / sum(PPxSero_matrix)
#PPxSero_matrix_prob <- matrix(sapply(PPxSero_matrix_prob,as.double), nrow = nrow(PPxSero_matrix), ncol = ncol(PPxSero_matrix))
#saveRDS(PPxSero_matrix_prob, "Navajo_PPsero_mig.rds")
PPxSero_matrix_prob2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPxSero_matrix_prob2[i,] <- ((PPxSero_matrix[i,] * Navajo_avg_cluster_freq[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPxSero_matrix_prob2, "Navajo_PPsero_mig.rds")
# new migration matrix that is closer to original one
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="1998")) {
PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPsero_startpop[PPclustToIndex_dict[PopPUNK_clusters$Cluster[i]],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
#PPsero_startpop <- PPsero_startpop * 15000 / sum(PPsero_startpop)
PP_expand_factor <- 15000 / sum(PPsero_startpop)
exp_noise <- 10
#PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
#PPsero_startpop_corr <- matrix(sapply(PPsero_startpop_corr,as.double), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
#saveRDS(PPsero_startpop_corr, "PPsero_startpop.rds")
# this lead to a start population that is way too evenly distributed across the different clusters
# instead, I could maybe use the existing PP_model_start_pop and distribute it to the different serotypes?
PPsero_startpop2 <-  matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:length(unique(PopPUNK_clusters$Cluster))) {
PPsero_startpop2[i,] <- round((PPxSero_matrix[i,] * Navajo_model_start_pop[i])/sum(PPxSero_matrix[i,]))
}
saveRDS(PPsero_startpop2, "Navajo_PPsero_startpop.rds")
# this is very close to the original PP_model_start_pop
# maybe I am giving out too much information because the serotype distribution is exactly the real one?
# serotype VT vector
SeroVT <- rep(0, length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
SeroVT[SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- as.integer(PopPUNK_clusters$VT[i]=="VT")
}
saveRDS(SeroVT, "Navajo_SeroVT.rds")
seq_clusters <- readRDS("UK_PP.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "UK_ggCaller_intermed_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
delta_ranking <- readRDS(file = "UK_delta_ranking.rds")
seq_clusters <- readRDS("UK_PP.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "UK_ggCaller_intermed_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
mass_clusters <- length(unique(seq_clusters$Cluster))
delta_ranking <- readRDS(file = "UK_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "UK_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "UK_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "UK_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "UK_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "UK_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "UK_cluster_freqs_6.rds")
mass_cluster_freq_7 <- readRDS(file = "UK_cluster_freqs_7.rds")
mass_VT <- readRDS(file = "UK_SeroVT.rds")
avg_cluster_freq <- readRDS(file = "UK_PPsero_mig.rds")
output_filename <- "UK_gPPxSero_gCaller_PopPUNK"
dt <- 1/12
peripost_mass_cluster_freq <- data.frame("year" = 1:6, rbind(mass_cluster_freq_2,mass_cluster_freq_3,mass_cluster_freq_4,mass_cluster_freq_5,mass_cluster_freq_6, mass_cluster_freq_7))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
vacc_time <- 0
sero_no = length(unique(seq_clusters$Serotype))
model_start_pop <- readRDS(file = "UK_PPsero_startpop.rds")
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- data.frame(model_start_pop)
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
migVec <- data.frame(avg_cluster_freq)
complex_params = list(species_no = species_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, Genotypes = intermed_gene_presence_absence_consensus[-1,-1], capacity = capacity, delta = delta, vaccTypes = vaccTypes, gene_no = gene_no, vacc_time = vacc_time, dt = dt, sigma_w = pmcmc_sigma_w, migVec = (migVec), sero_no = sero_no)
make_transform <- function(m) {
function(theta) {
as_double_mtx <- function(x){
sapply(x,as.double)
}
c(lapply(m, as_double_mtx), as.list(theta))
}
}
proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
proposal_matrix[1,1] <- exp(0.1)
proposal_matrix[3,3] <- exp(0.1)
index <- function(info) {
list(run = c(sum_clust = info$index$Pop_tot),
state = c(Pop = info$index$Pop))
}
#proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars$initial()
#WF$public_methods$has_openmp()
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
index = index,
compare = combined_compare)
n_steps <- 5
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 1)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains =4, n_workers = 4,
n_threads_total = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)
print("det_mcmc_1 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_1 mean log likelihood")
mean(processed_chains$probabilities[,2])
# compare this VT divers run with normal run
# because the likelihood is much better but the lollipop looks basically the same.
seq_clusters <- readRDS("Navajo_PP.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "Navajo_ggCaller_intermed_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "Navajo_model_start_pop.rds")
delta_ranking <- readRDS(file = "Navajo_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "Navajo_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "Navajo_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "Navajo_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "Navajo_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "Navajo_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "Navajo_cluster_freqs_6.rds")
# with 6A in PCV7
Navajo_VT <- readRDS("/Users/llorenz/Documents/PhD_Project/Code/1st_project/WF_plots_postTAC/2024_08_14/Navajo_VT_1vacc_with6A/Navajo_VT_ggCaller_PopPUNK_det_pmcmc_run2.rds")
Navajo_VT_mcmc <- coda::as.mcmc(cbind(Navajo_VT$probabilities, Navajo_VT$pars))
coda::effectiveSize(Navajo_VT_mcmc)
summary(coda::as.mcmc(Navajo_VT_mcmc))
pars_from_mcmc_Navajo <- map_estimate(Navajo_VT$pars[, 1:4])$MAP_Estimate
pars_from_mcmc_Navajo
# mean from same run: -2.7741 0.2691 -3.1262 0.3377
#pars_from_mcmc_Navajo <- c(-2.7741, 0.2691, -3.1262, 0.3377)
read_VT_data_and_lollipop("Navajo", pars_from_mcmc_Navajo)
# compare this VT divers run with normal run
# because the likelihood is much better but the lollipop looks basically the same.
seq_clusters <- readRDS("Navajo_PP.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "Navajo_ggCaller_intermed_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "Navajo_model_start_pop.rds")
delta_ranking <- readRDS(file = "Navajo_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "Navajo_cluster_freqs_1.rds")
mass_cluster_freq_2 <- readRDS(file = "Navajo_cluster_freqs_2.rds")
mass_cluster_freq_3 <- readRDS(file = "Navajo_cluster_freqs_3.rds")
mass_cluster_freq_4 <- readRDS(file = "Navajo_cluster_freqs_4.rds")
mass_cluster_freq_5 <- readRDS(file = "Navajo_cluster_freqs_5.rds")
mass_cluster_freq_6 <- readRDS(file = "Navajo_cluster_freqs_6.rds")
mass_cluster_freq_7 <- readRDS(file = "Navajo_cluster_freqs_7.rds")
mass_cluster_freq_8 <- readRDS(file = "Navajo_cluster_freqs_8.rds")
mass_cluster_freq_9 <- readRDS(file = "Navajo_cluster_freqs_9.rds")
mass_cluster_freq_10 <- readRDS(file = "Navajo_cluster_freqs_10.rds")
mass_cluster_freq_11 <- readRDS(file = "Navajo_cluster_freqs_11.rds")
mass_cluster_freq_12 <- readRDS(file = "Navajo_cluster_freqs_12.rds")
mass_cluster_freq_13 <- readRDS(file = "Navajo_cluster_freqs_13.rds")
mass_cluster_freq_14 <- readRDS(file = "Navajo_cluster_freqs_14.rds")
mass_cluster_freq_15 <- readRDS(file = "Navajo_cluster_freqs_15.rds")
mass_VT <- readRDS(file = "Navajo_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
output_filename <- "Navajo_VT_ggCaller_PopPUNK"
dt <- 1/12
peripost_mass_cluster_freq <- data.frame("year" = 1:14, rbind(mass_cluster_freq_2,mass_cluster_freq_3,mass_cluster_freq_4,mass_cluster_freq_5,mass_cluster_freq_6, mass_cluster_freq_7, mass_cluster_freq_8, mass_cluster_freq_9,mass_cluster_freq_10, mass_cluster_freq_11, mass_cluster_freq_12, mass_cluster_freq_13,mass_cluster_freq_14,mass_cluster_freq_15))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
vacc_time <- 2 # trying vacc time =2 instead of 5 as before
ceil_mass_NVT <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
ceil_mass_NVT[i] <- ceiling(mean(as.integer(seq_clusters[seq_clusters$Cluster == unique(seq_clusters$Cluster)[i],"VT"]=="NVT")))
}
#ceil_mass_NVT[is.nan(ceil_mass_NVT)] <- 0
mean_mass_VT_start <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
mean_mass_VT_start[i] <- (mean(as.integer(seq_clusters[seq_clusters$SeqYear == 1999 & seq_clusters$Cluster == unique(seq_clusters$Cluster)[i],"VT"]=="VT")))
}
mean_mass_VT_start[is.nan(mean_mass_VT_start)] <- 0
NVT_mig <- rep(1/mass_clusters, mass_clusters) * (ceil_mass_NVT)
VT_mig <- rep(1/mass_clusters, mass_clusters) * (1-ceil_mass_NVT)
avg_cluster_freq <- data.frame(as.matrix(cbind(NVT_mig,VT_mig)))
model_start_pop <- matrix(as.double(c(model_start_pop * (1-mean_mass_VT_start),model_start_pop * mean_mass_VT_start)), byrow = FALSE, nrow = mass_clusters, ncol = 2)
ggCPP_params <- list(dt = 1/12, species_no =mass_clusters,  gene_no = nrow(intermed_gene_presence_absence_consensus)-1, Pop_ini = ( model_start_pop), Pop_eq = Pop_eq <- rowSums(model_start_pop), capacity = sum( model_start_pop), Genotypes = intermed_gene_presence_absence_consensus_matrix, sigma_f = pars_from_mcmc_Navajo[1], prop_f = pars_from_mcmc_Navajo[2], sigma_w =-1000 , delta = delta_ranking, m = pars_from_mcmc_Navajo[3], migVec =  as.matrix(avg_cluster_freq), v = pars_from_mcmc_Navajo[4] , vT = c(0,1), vacc_time = 0)
Navajo_PP_serotype_comp <- rep(0,mass_clusters)
for (i in 1:mass_clusters) {
Navajo_PP_serotype_comp[i] <- paste(unique(seq_clusters$Serotype[which(seq_clusters$Cluster==unique(seq_clusters$Cluster)[i])]), collapse = ", ")
}
WF <- odin.dust::odin_dust("NFDS_Model_VT.R")
WFmodel <- WF$new(pars = ggCPP_params,
time = 0,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
simMeanggCPP10_Navajo <- rowMeans(WFmodel$run(108)[-1,])[1:mass_clusters]
simMeanggCPP13_Navajo <- rowMeans(WFmodel$run(144)[-1,])[1:mass_clusters]
simMeanggCPP14_Navajo <- rowMeans(WFmodel$run(156)[-1,])[1:mass_clusters]
simMeanggCPP15_Navajo <- rowMeans(WFmodel$run(168)[-1,])[1:mass_clusters]
VT_14 <- simMeanggCPP14_Navajo # computed here
# compute serotype composition of PP clusters
Navajo_PP_serotype_comp <- rep(0,mass_clusters)
for (i in 1:mass_clusters) {
Navajo_PP_serotype_comp[i] <- paste(unique(seq_clusters$Serotype[which(seq_clusters$Cluster==unique(seq_clusters$Cluster)[i])]), collapse = ", ")
}
lollipop_cluster_freqs_2x2_VTandNVT_labelSero(year = "tp 14", plot_title = "Navajo - Standard vs. VT-divers Model", data_name = "Data", data1 = mass_cluster_freq_14/sum(mass_cluster_freq_14), model_name_1 ="VT-divers Model", model1 = VT_14/sum(VT_14), model_name_2 ="Standard Model", model2 = standard_14_Navajo/sum(standard_14_Navajo), mass_VT, SeroLabel = Navajo_PP_serotype_comp)
lollipop_cluster_freqs_VTandNVT_labelSero_relative_ModelComp(year = "tp 14", plot_title = "Navajo - Standard vs. VT-divers Model", data_name = "Data", data1 = mass_cluster_freq_14/sum(mass_cluster_freq_14), model_name_1 ="VT-divers Model", model1 = VT_14/sum(VT_14), model_name_2 ="Standard Model", model2 = standard_14_Navajo/sum(standard_14_Navajo), mass_VT, SeroLabel = Navajo_PP_serotype_comp)
lollipop_cluster_freqs_2x2_VTandNVT_labelSero(year = "tp 14", plot_title = "Navajo - Standard vs. VT-divers Model", data_name = "Data", data1 = mass_cluster_freq_14/sum(mass_cluster_freq_14), model_name_1 ="VT-divers Model", model1 = VT_14/sum(VT_14), model_name_2 ="Standard Model", model2 = standard_14_Navajo/sum(standard_14_Navajo), mass_VT, SeroLabel = Navajo_PP_serotype_comp)
lollipop_cluster_freqs_VTandNVT_labelSero_relative_ModelComp(year = "tp 14", plot_title = "Navajo - Standard vs. VT-divers Model", data_name = "Data", data1 = mass_cluster_freq_14/sum(mass_cluster_freq_14), model_name_1 ="VT-divers Model", model1 = VT_14/sum(VT_14), model_name_2 ="Standard Model", model2 = standard_14_Navajo/sum(standard_14_Navajo), mass_VT, SeroLabel = Navajo_PP_serotype_comp)
