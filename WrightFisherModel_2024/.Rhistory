proposal_matrix <- diag(0.1,4) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 01), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", -0.597837, min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", 0.125, min = 0, max = 1), mcstate::pmcmc_parameter("m", -4, min = -1000, max = 0), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
mean(processed_chains$probabilities[,2])
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = -1000, max = 0), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[2], min = 0, max = 1),mcstate::pmcmc_parameter("m", parameter_mean_hpd[3], min = -1000, max = 0), mcstate::pmcmc_parameter("v", parameter_mean_hpd[4], min = 0, max = 1)), det_proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 2000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 1000, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
print("det_mcmc_2 final log likelihood")
processed_chains$probabilities[nrow(processed_chains$probabilities),2]
print("det_mcmc_2 mean log likelihood")
mean(processed_chains$probabilities[,2])
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
library(coda)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_VT.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state[2:mass_clusters+1, , drop = TRUE]))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
seq_clusters <- readRDS("PopPUNK_clusters.rds")
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
#mass_VT <- readRDS(file = "PP_mass_VT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
#avg_cluster_freq <- rep(1/mass_clusters, mass_clusters)
ceil_mass_NVT <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
ceil_mass_NVT[i] <- ceiling(mean(as.integer(seq_clusters[seq_clusters$Cluster == i,"VT"]=="NVT")))
}
mean_mass_VT_2001 <- rep(0, mass_clusters)
for (i in 1:mass_clusters){
mean_mass_VT_2001[i] <- (mean(as.integer(seq_clusters[seq_clusters$SeqYear == 2001 & seq_clusters$Cluster == i,"VT"]=="VT")))
}
mean_mass_VT_2001[is.nan(mean_mass_VT_2001)] <- 0
NVT_mig <- rep(1/mass_clusters, mass_clusters) * (ceil_mass_NVT)
VT_mig <- rep(1/mass_clusters, mass_clusters) * (1-ceil_mass_NVT)
avg_cluster_freq <- cbind(NVT_mig,VT_mig)
model_start_pop <- matrix(as.double(c(model_start_pop * (1-mean_mass_VT_2001),model_start_pop * mean_mass_VT_2001)), byrow = FALSE, nrow = mass_clusters, ncol = 2)
output_filename <- "VT_ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- rowSums(model_start_pop)
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
#vaccTypes <- mass_VT
vT = c(0,1)
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, species_no, gene_no, vacc_time, dt, migVec,vT)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = matrix(p[1:2*mass_clusters], nrow = species_no, ncol = 2),
Pop_eq = p[(2*mass_clusters +1) : (2*mass_clusters + mass_clusters)],
Genotypes = matrix(p[(2*mass_clusters + mass_clusters + 1): ((2*mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((3 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((3 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((3 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
#vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = matrix(p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + 2*species_no - 1)], nrow = species_no, ncol = 2),
vT = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + 2*species_no):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + 2*species_no + 1)]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
print(parameter_mean_hpd)
mean(processed_chains$probabilities[,2])
avg_cluster_freq
rowSums(avg_cluster_freq)
model_start_pop
NVT_mig
VT_mig
ceil_mass_NVT
intermed_gene_presence_absence_consensus_matrix
View(intermed_gene_presence_absence_consensus)
serotypes_in_clust
Serotype_dict
sort(unique(Serotype_dict))
View(PopPUNK_clusters.rds)
View(PopPUNK_clusters)
View(PopPUNK_clusters)
PopPUNK_clusters <- readRDS("PopPUNK_clusters.rds")
length(unique(PopPUNK_clusters$Cluster))
PPxSero_matrix <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
unique(PopPUNK_clusters$Cluster)
unique(PopPUNK_clusters$Serotype))
unique(PopPUNK_clusters$Serotype)
sort(unique(PopPUNK_clusters$Serotype))
length(unique(PopPUNK_clusters$Serotype))
SerotypeToIndex_dict <- 1:length(unique(PopPUNK_clusters$Serotype))
names(SerotypeToIndex_dict) <- sort(unique(PopPUNK_clusters$Serotype))
SerotypeToIndex_dict
nrow(PopPUNK_clusters)
for (i in 1:nrow(PopPUNK_clusters)) {
PPxSero_matrix[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
PPxSero_matrix
sum(PPxSero_matrix)
PPxSero_matrix <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
PPxSero_matrix[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPxSero_matrix[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
sum(PPxSero_matrix)
# matrix shows information whether PP and serotype co-occur in the dataset (1=TRUE)
# this can be used as the migration matrix
PPxSero_matrix_prob <- PPxSero_matrix_prob / sum(PPxSero_matrix_prob)
# matrix shows information whether PP and serotype co-occur in the dataset (1=TRUE)
# this can be used as the migration matrix
PPxSero_matrix_prob <- PPxSero_matrix / sum(PPxSero_matrix)
PPxSero_matrix_prob
PPxSero_matrix
PPxSero_matrix <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
PPxSero_matrix[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
# matrix shows information whether PP and serotype co-occur in the dataset (1=TRUE)
# this can be used as the migration matrix
PPxSero_matrix_prob <- PPxSero_matrix / sum(PPxSero_matrix)
PPxSero_matrix_prob
which(PopPUNK_clusters$SeqYear=="2001")
for (i in which(PopPUNK_clusters$SeqYear=="2001")) {
PPsero_startpop[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="2001")) {
PPsero_startpop[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- 1
}
PPsero_startpop
sum(PPsero_startpop)
length(which(PopPUNK_clusters$SeqYear=="2001"))
saveRDS(PPxSero_matrix_prob, "PPsero_mig.rds")
PPsero_startpop <- PPsero_startpop * 15000 / sum(PPsero_startpop)
PPsero_startpop
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="2001")) {
PPsero_startpop[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPsero_startpop[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
sum(PPsero_startpop)
PPsero_startpop <- PPsero_startpop * 15000 / sum(PPsero_startpop)
PPsero_startpop
saveRDS(PPsero_startpop, "PPsero_startpop.rds")
WF_PPxSero <- odin.dust::odin_dust("NFDS_Model_PPxSero.R")
WF_PPxSero <- odin.dust::odin_dust("NFDS_Model_PPxSero.R")
PopPUNK_clusters <- readRDS("PopPUNK_clusters.rds")
PP_intermed_gene_presence_absence_consensus <- readRDS(file = "PP_intermed_gene_presence_absence_consensus.rds")
PP_intermed_gene_presence_absence_consensus_matrix <- sapply(PP_intermed_gene_presence_absence_consensus[-1,-1],as.double)
PP_model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
#delta_ranking <- readRDS(file = "delta_ranking.rds")
PP_mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
PP_mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
PP_mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
PP_mass_VT <- readRDS(file = "PP_mass_VT.rds")
PopPUNK_clusters <- readRDS("PopPUNK_clusters.rds")
ggCPP_intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
ggCPP_intermed_gene_presence_absence_consensus_matrix <- sapply(ggCPP_intermed_gene_presence_absence_consensus[-1,-1],as.double)
PP_model_start_pop <- readRDS(file = "PP_model_start_pop.rds")
ggC_delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
PP_mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
PP_mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
PP_mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
PP_mass_VT <- readRDS(file = "PP_mass_VT.rds")
PP_mass_clusters <- length(unique(PopPUNK_clusters$Cluster))
PP_avg_cluster_freq <- rep(1/PP_mass_clusters, PP_mass_clusters)
PPsero_startpop
Sero_mass_VT
# serotype VT vector
SeroVT <- rep(0, length(unique(PopPUNK_clusters$Serotype)))
PopPUNK_clusters$VT[1]=="VT"
as.integer(PopPUNK_clusters$VT[1]=="VT")
# serotype VT vector
SeroVT <- rep(0, length(unique(PopPUNK_clusters$Serotype)))
for (i in 1:nrow(PopPUNK_clusters)) {
SeroVT[SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- as.integer(PopPUNK_clusters$VT[i]=="VT")
}
SeroVT
saveRDS(SeroVT, "SeroVT.rds")
PPxSero_params <- list(dt = 1/36, species_no = PP_mass_clusters, sero_no = length(unique(PopPUNK_clusters$Serotype)), gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = PPsero_startpop, Pop_eq = PPsero_startpop, capacity = sum(PPsero_startpop), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = log(0.14), prop_f = 0.38, delta = ggC_delta_ranking, m = log(0.011), migVec = PPxSero_matrix_prob, vaccTypes = SeroVT, v = 0.15, vacc_time = 0)
WFmodel_ppxSero <- WF_PPxSero$new(pars = PPxSero_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
PPsero_startpop
rowSums(PPsero_startpop)
sum(PPsero_startpop)
# start population:
PPsero_startpop <- matrix(0, nrow = length(unique(PopPUNK_clusters$Cluster)), ncol = length(unique(PopPUNK_clusters$Serotype)))
for (i in which(PopPUNK_clusters$SeqYear=="2001")) {
PPsero_startpop[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] <- PPsero_startpop[PopPUNK_clusters$Cluster[i],SerotypeToIndex_dict[PopPUNK_clusters$Serotype[i]]] + 1
}
sum(PPsero_startpop)
PP_expand_factor <- 15000 / sum(PPsero_startpop)
exp_noise <- 10
PPsero_startpop_corr <- (sapply((PPsero_startpop + rexp(n = length(PPsero_startpop), rate = exp_noise)) * PP_expand_factor, rpois, n=1))
PPsero_startpop_corr
PPsero_startpop
rexp(n = length(PPsero_startpop), rate = exp_noise))
rexp(n = length(PPsero_startpop), rate = exp_noise)
rexp(n = length(PPsero_startpop), rate = exp_noise)) * PP_expand_factor, rpois, n=1)
### create initial population that is based on the 2001 data set but not an exact sampling from it
# but a Poisson process
PP_expand_factor <- 15000 / sum(PP_mass_cluster_freq_1)
exp_noise <- 10
PP_model_start_pop <- (sapply((PP_mass_cluster_freq_1 + rexp(n = length(PP_mass_cluster_freq_1), rate = exp_noise)) * PP_expand_factor, rpois, n=1))
PP_model_start_pop
PP_expand_factor <- 15000 / sum(PPsero_startpop)
exp_noise <- 10
PPsero_startpop_corr <- (sapply((PPsero_startpop + as.matrix(rexp(n = length(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop)) * PP_expand_factor, rpois, n=1))
PPsero_startpop_corr <- (sapply((PPsero_startpop + as.matrix(rexp(n = length(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1))
PPsero_startpop + as.matrix(rexp(n = length(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop)))
PPsero_startpop + as.matrix(rexp(n = length(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
as.matrix(rexp(n = length(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr <- (sapply((PPsero_startpop + as.matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1))
as.matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr <- (sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1))
PPsero_startpop_corr
PPsero_startpop_corr <- (sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois))
PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr
saveRDS(PPsero_startpop_corr, "PPsero_startpop.rds")
rowSums(PPsero_startpop_corr)
PPxSero_params <- list(dt = 1/36, species_no = PP_mass_clusters, sero_no = length(unique(PopPUNK_clusters$Serotype)), gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = PPsero_startpop_corr, Pop_eq = rowSums(PPsero_startpop_corr), capacity = sum(PPsero_startpop_corr), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = log(0.14), prop_f = 0.38, delta = ggC_delta_ranking, m = log(0.011), migVec = PPxSero_matrix_prob, vaccTypes = SeroVT, v = 0.15, vacc_time = 0)
WFmodel_ppxSero <- WF_PPxSero$new(pars = PPxSero_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
WF_PPxSero <- odin.dust::odin_dust("NFDS_Model_PPxSero.R")
WF_PPxSero <- odin.dust::odin_dust("NFDS_Model_PPxSero.R")
PPxSero_params <- list(dt = 1/36, species_no = PP_mass_clusters, sero_no = length(unique(PopPUNK_clusters$Serotype)), gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = PPsero_startpop_corr, Pop_eq = rowSums(PPsero_startpop_corr), capacity = sum(PPsero_startpop_corr), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = log(0.14), prop_f = 0.38, delta = ggC_delta_ranking, m = log(0.011), migVec = PPxSero_matrix_prob, vaccTypes = SeroVT, v = 0.15, vacc_time = 0)
WFmodel_ppxSero <- WF_PPxSero$new(pars = PPxSero_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
rowSums(PPsero_startpop_corr)
PPsero_startpop_corr
PPsero_startpop_corr <- sapply(PPsero_startpop_corr,as.double)
saveRDS(PPsero_startpop_corr, "PPsero_startpop.rds")
PPxSero_matrix_prob <- sapply(PPxSero_matrix_prob,as.double)
saveRDS(PPxSero_matrix_prob, "PPsero_mig.rds")
PPxSero_params <- list(dt = 1/36, species_no = PP_mass_clusters, sero_no = length(unique(PopPUNK_clusters$Serotype)), gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = PPsero_startpop_corr, Pop_eq = as.double(rowSums(PPsero_startpop_corr)), capacity = sum(PPsero_startpop_corr), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = log(0.14), prop_f = 0.38, delta = ggC_delta_ranking, m = log(0.011), migVec = PPxSero_matrix_prob, vaccTypes = SeroVT, v = 0.15, vacc_time = 0)
PPsero_startpop_corr
PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr <- sapply(PPsero_startpop_corr,as.double)
PPsero_startpop_corr
sapply(PPsero_startpop_corr,as.double)
PP_intermed_gene_presence_absence_consensus_matrix <- sapply(PP_intermed_gene_presence_absence_consensus[-1,-1],as.double)
PP_intermed_gene_presence_absence_consensus_matrix
PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr <- sapply(PPsero_startpop_corr,as.double, simplify = FALSE)
PPsero_startpop_corr
PPsero_startpop_corr <- matrix(sapply((PPsero_startpop + matrix(rexp(n = ncol(PPsero_startpop) * nrow(PPsero_startpop), rate = exp_noise), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))) * PP_expand_factor, rpois, n=1), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr <- matrix(sapply(PPsero_startpop_corr,as.double), nrow= nrow(PPsero_startpop), ncol = ncol(PPsero_startpop))
PPsero_startpop_corr
saveRDS(PPsero_startpop_corr, "PPsero_startpop.rds")
PPxSero_params <- list(dt = 1/36, species_no = PP_mass_clusters, sero_no = length(unique(PopPUNK_clusters$Serotype)), gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = PPsero_startpop_corr, Pop_eq = as.double(rowSums(PPsero_startpop_corr)), capacity = sum(PPsero_startpop_corr), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = log(0.14), prop_f = 0.38, delta = ggC_delta_ranking, m = log(0.011), migVec = PPxSero_matrix_prob, vaccTypes = SeroVT, v = 0.15, vacc_time = 0)
WFmodel_ppxSero <- WF_PPxSero$new(pars = PPxSero_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
# matrix shows information whether PP and serotype co-occur in the dataset (1=TRUE)
# this can be used as the migration matrix:
PPxSero_matrix_prob <- PPxSero_matrix / sum(PPxSero_matrix)
PPxSero_matrix_prob <- matrix(sapply(PPxSero_matrix_prob,as.double), nrow = nrow(PPxSero_matrix), ncol = ncol(PPxSero_matrix))
saveRDS(PPxSero_matrix_prob, "PPsero_mig.rds")
PPxSero_params <- list(dt = 1/36, species_no = PP_mass_clusters, sero_no = length(unique(PopPUNK_clusters$Serotype)), gene_no = nrow(ggCPP_intermed_gene_presence_absence_consensus)-1, Pop_ini = PPsero_startpop_corr, Pop_eq = as.double(rowSums(PPsero_startpop_corr)), capacity = sum(PPsero_startpop_corr), Genotypes = ggCPP_intermed_gene_presence_absence_consensus_matrix, sigma_f = log(0.14), prop_f = 0.38, delta = ggC_delta_ranking, m = log(0.011), migVec = PPxSero_matrix_prob, vaccTypes = SeroVT, v = 0.15, vacc_time = 0)
WFmodel_ppxSero <- WF_PPxSero$new(pars = PPxSero_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
WFmodel_ppxSero$run(10)
### Loading packages
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
#install.packages("mcstate")
library(mcstate)
#install.packages("mcstate")
library(mcstate)
library(coda)
# read in model from file
WF <- odin.dust::odin_dust("NFDS_Model_PPxSero.R")
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
WFmodel_ppxSero$run(1)
WFmodel_ppxSero <- WF_PPxSero$new(pars = PPxSero_params,
time = 1,
n_particles = 10L,
n_threads = 4L,
seed = 1L)
WFmodel_ppxSero$run(1)
# likelihood for fitting:
ll_pois <- function(obs, model) {
exp_noise <- 1e6
if (is.na(obs)) {
# Creates vector of zeros in ll with same length, if no data
ll_obs <- numeric(length(model))
} else {
lambda <- model + rexp(n = length(model), rate = exp_noise)
ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
}
ll_obs
}
combined_compare <- function(state, observed, pars = NULL) {
result <- 0
#data_size <- sum(mass_cluster_freq_1)
#model_size = 15000
data_size <- sum(unlist(observed))
model_size = sum(unlist(state[2:mass_clusters+1, , drop = TRUE]))
for (i in 1:mass_clusters){
result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
}
result
}
saveRDS(PPxSero_matrix_prob, "PPsero_mig.rds")
saveRDS(SeroVT, "SeroVT.rds")
seq_clusters <- readRDS("PopPUNK_clusters.rds")
sero_no = length(unique(seq_clusters$Serotype))
intermed_gene_presence_absence_consensus <- readRDS(file = "ggCPP_intermed_gene_presence_absence_consensus.rds")
intermed_gene_presence_absence_consensus_matrix <- sapply(intermed_gene_presence_absence_consensus[-1,-1],as.double)
model_start_pop <- readRDS(file = "PPsero_startpop.rds")
delta_ranking <- readRDS(file = "ggC_delta_ranking.rds")
mass_cluster_freq_1 <- readRDS(file = "PP_mass_cluster_freq_1.rds")
mass_cluster_freq_2 <- readRDS(file = "PP_mass_cluster_freq_2.rds")
mass_cluster_freq_3 <- readRDS(file = "PP_mass_cluster_freq_3.rds")
mass_VT <- readRDS(file = "SeroVT.rds")
mass_clusters <- length(unique(seq_clusters$Cluster))
avg_cluster_freq <- readRDS(file = "PPsero_mig.rds")
output_filename <- "PPxSero_ggCaller_PopPUNK"
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
time = "year",
rate = 1 / dt,
initial_time = 0)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF,
compare = combined_compare)
# Using MCMC to infer parameters
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
#pmcmc_sigma_w <- 0
pmcmc_sigma_w <- -1000
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.2, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(intermed_gene_presence_absence_consensus_matrix)
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- intermed_gene_presence_absence_consensus_matrix
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec, pmcmc_sigma_w)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:mass_clusters],
Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)],
sigma_w = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1 + 1)]), as.list(theta))
}
}
