---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r}
# reading in the massachussets preprocessed data we received from Nick Croucher
# it contains info about serotype, vaccine type (VT), sequence cluster (SC) and the gene-presence-absence matrix
mass_data <- read.delim("~/Documents/PhD_Project/Data/Massachusetts_data_NickCroucher/mass.input")

#sort(unique(mass_data$SC))
# [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
# --> we have 41 sequence clusters (in PopPUNK there were 62 sequence clusters)
```

```{r}
# compute gene frequencies
sum_as_int <- function(x){
  sum(as.integer(x))
}

gene_freq <- rep(0, ncol(mass_data)-5)
gene_freq_mass_data <- mass_data[1:nrow(mass_data),6:ncol(mass_data)]

gene_freq <- apply(gene_freq_mass_data,2, sum_as_int)
gene_freq <- gene_freq / (length(gene_freq_mass_data[,1]))

#> sum(gene_freq <= 0.95 & gene_freq >= 0.05)
#[1] 1062
#> sum(gene_freq <= 1)
#[1] 5425

#create sub-data set for the intermediate frequency genes (5-95% across all sequences)
intermed_mass_data <- data.frame(matrix(ncol = sum(gene_freq <= 0.95 & gene_freq >= 0.05) + 5, nrow = nrow(mass_data)))
intermed_mass_data[,1:5] <- mass_data[,1:5]
colnames(intermed_mass_data)[1:5] <- colnames(mass_data)[1:5]
counter <- 1
for (i in 1:length(gene_freq)){
  if (0.05 <= gene_freq[i] & gene_freq[i] <= 0.95 ){
    intermed_mass_data[,counter+5] <- mass_data[,i+5]
    colnames(intermed_mass_data)[counter+5] <- colnames(mass_data)[i+5]
    counter <- counter + 1
  }
}
```




```{r}
### compute consensus genomes for sequence clusters
# and I will transform the data frame, so that the genes are the rows and the columns are the clusters
mass_clusters <- length(unique(mass_data$SC))
mass_consensus_presence_absence <- data.frame(matrix(nrow = sum(gene_freq <= 0.95 & gene_freq >= 0.05), ncol = mass_clusters+1))

mass_consensus_presence_absence[,1] <- colnames(intermed_mass_data)[-(1:5)]
colnames(mass_consensus_presence_absence) <- c('genes', sort(unique(mass_data$SC)))


mean_mass_cluster_freq <- mass_consensus_presence_absence # this is just to assess how valid it is to make consensus genomes

cons_genomes <- function(x){
  as.double(median(as.integer(x)))
}

cons_genomes_mean <- function(x){
  as.double(mean(as.integer(x)))
}

for (i in 0:(mass_clusters-1)){
  curr_genomes <- intermed_mass_data[which(intermed_mass_data$SC==i),-(1:5)] # select all genomes in cluster i
  #cluster_gene_presence_absence[j,i+3] <- as.double(median(as.integer(curr_genomes[j,])))
  mass_consensus_presence_absence[,i+2] <- apply(curr_genomes,2,cons_genomes)
  
  mean_mass_cluster_freq[,i+2] <- apply(curr_genomes,2,cons_genomes_mean)
}
```

```{r}
# calculate frequencies of genes of with within-cluster frequency of 0, 1 and in-between

# calculate actual percentages of mean 0, 1 and in-between
zero_count <- 0
one_count <- 0
intermed_count <- 0
for (i in 1:nrow(mean_mass_cluster_freq)){
  for (j in 2:ncol(mean_mass_cluster_freq)){
    if(mean_mass_cluster_freq[i,j]==0){
      zero_count <- zero_count + 1
    }
    else if(mean_mass_cluster_freq[i,j]==1){
      one_count <- one_count + 1
    }
    else{
      intermed_count <- intermed_count + 1
    }
  }
}
zero_count
one_count
intermed_count
zero_frac <- zero_count / (zero_count + one_count + intermed_count)
intermed_frac <- intermed_count / (zero_count + one_count + intermed_count)
one_frac <- one_count / (zero_count + one_count + intermed_count)

zero_frac
intermed_frac
one_frac
```
```{r}
#calculate the frequency of the gene clusters and year
mass_cluster_freq_1 <- rep(0,mass_clusters)
mass_cluster_freq_2 <- rep(0,mass_clusters)
mass_cluster_freq_3 <- rep(0,mass_clusters)
for (i in 1:mass_clusters){
  mass_cluster_freq_1[i] <- length(which(mass_data[which(mass_data$SC==i-1),]$Time==0))
  mass_cluster_freq_2[i] <- length(which(mass_data[which(mass_data$SC==i-1),]$Time==36))
  mass_cluster_freq_3[i] <- length(which(mass_data[which(mass_data$SC==i-1),]$Time==72))
}

```

```{r}
# calculate Vaccine Type consensus for clusters
mass_VT <- rep(0, mass_clusters)
mass_VT_mean <- rep(0, mass_clusters)

for (i in 1:mass_clusters){
  curr_VTs <- subset(mass_data,mass_data$SC == i-1)$VT # select all genomes in cluster i-1
  mass_VT[i] <- ceiling(median(curr_VTs))
  mass_VT_mean[i] <- mean(curr_VTs)
  #print(mass_VT_mean[i]) #calculate mean as check for consensus
}
```

```{r}
# plot cluster freq coloured by vacc type, non VT and mixed
#create colour-vector based on VT mean info
mass_VT_colours <- rep("black",mass_clusters)
for (i in 1:mass_clusters){
  if(mass_VT_mean[i] ==1){
    mass_VT_colours[i] <- "#E69F00"
  }
  else if(mass_VT_mean[i] ==0){
    mass_VT_colours[i] <- "#56B4E9"
  }
}

par(mfrow=c(1,1))
op <- par(mar = c(5,7,4,2) + 0.1,mgp=c(3,1,0))
plot(mass_cluster_freq_1 / sum(mass_cluster_freq_1), mass_cluster_freq_3 / sum(mass_cluster_freq_3), axes = FALSE, ann = FALSE, pch = 19, col = mass_VT_colours)
legend("topleft", title = "Clusters", c("VT", "Non-VT", "mixed"),fill = c("#E69F00", "#56B4E9", "black" ))
axis(1,cex.axis = 1.5)
axis(2, cex.axis = 1.5)
title(xlab = "Pre-vaccine cluster frequency", cex.lab=1.5)
title(ylab = "Post-vaccine cluster frequency", cex.lab = 1.5,
      line = 4.5)
box()
par(op)
```

```{r}
# I want to include low and high levels of selection to the model.
# for that I need to calculate the beta statistics

# calculate gene frequencies first, separate for three times
#mass_gene_freq_0 <- rep(0, ncol(mass_data)-5)
#mass_gene_freq_36 <- rep(0, ncol(mass_data)-5)
#mass_gene_freq_72 <- rep(0, ncol(mass_data)-5)

mass_gene_freq_0 <- apply(intermed_mass_data[which(intermed_mass_data$Time==0),][,-(1:5)], 2, sum)
mass_gene_freq_36 <- apply(intermed_mass_data[which(intermed_mass_data$Time==36),][,-(1:5)], 2, sum)
mass_gene_freq_72 <- apply(intermed_mass_data[which(intermed_mass_data$Time==72),][,-(1:5)], 2, sum)

# first, calculate pre/peri and post vacc frequencies of genes:
pre_peri_vacc_gene_freq <- (mass_gene_freq_0 + mass_gene_freq_36) / (nrow(subset(mass_data,mass_data$Time==0)) + nrow(subset(mass_data,mass_data$Time==36)))
pre_vacc_gene_freq <- (mass_gene_freq_0) / nrow(subset(mass_data,mass_data$Time==0))
post_vacc_gene_freq <- mass_gene_freq_72 / nrow(subset(mass_data,mass_data$Time==72))
peri_post <- (mass_gene_freq_36 + mass_gene_freq_72) / (nrow(subset(mass_data,mass_data$Time==36)) + nrow(subset(mass_data,mass_data$Time==72)))

# calculate delta statistic (refer to Corander et al. for more info)
delta_data <- (post_vacc_gene_freq - pre_peri_vacc_gene_freq) ^ 2 / (1 - pre_peri_vacc_gene_freq * (1 - pre_peri_vacc_gene_freq))
delta_ranking <- rank(delta_data)

delta_data2 <- (post_vacc_gene_freq - pre_vacc_gene_freq) ^ 2 / (1 - pre_vacc_gene_freq * (1 - pre_vacc_gene_freq))
delta_ranking2 <- rank(delta_data2)

delta_data3 <- (peri_post - pre_vacc_gene_freq) ^ 2 / (1 - pre_vacc_gene_freq * (1 - pre_vacc_gene_freq))
delta_ranking3 <- rank(delta_data3)
delta_ranking <- delta_ranking3

```

```{r}
### create initial population that is based on the 2001 data set but not an exact sampling from it
# but a Poisson process
expand_factor <- 15000 / sum(mass_cluster_freq_1)
exp_noise <- 10
model_start_pop <- (sapply((mass_cluster_freq_1 + rexp(n = length(mass_cluster_freq_1), rate = exp_noise)) * expand_factor, rpois, n=1))

# visual check for the "sampling"
plot(mass_cluster_freq_1/sum(mass_cluster_freq_1))
points(model_start_pop/sum(model_start_pop), col = "red")
# looks similar enough, I would say
```

### READ IN THE MODEL FROM THE MODEL FILE
```{r}
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
```

```{r}
WF_nG_h_vP <- odin.dust::odin_dust("WrightFisher_newData_nGenotypes_haploid_PopsizeVariablePois.R")
#, options = odin.dust::odin_dust_options(options=odin::odin_options(workdir="~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/WrightFisherModel")))
```

#define parameters for the model:
```{r}
avg_cluster_freq <- (mass_cluster_freq_1 + mass_cluster_freq_2 + mass_cluster_freq_3)/(sum(mass_cluster_freq_1)+sum(mass_cluster_freq_2)+sum(mass_cluster_freq_3))

params_n_vP <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(mass_consensus_presence_absence), Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = as.matrix(mass_consensus_presence_absence[,-1]), sigma_f = 0.14, sigma_w = 0.002, prop_f = 0.25, delta = delta_ranking, m = 0.03, migVec = avg_cluster_freq, vaccTypes = mass_VT, v = 0.1, vacc_time = 0)

params_n_vP <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(mass_consensus_presence_absence), Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = as.matrix(mass_consensus_presence_absence[,-1]), sigma_f = 0.14, sigma_w = 0.002, prop_f = 0.25, delta = delta_ranking, m = 0.03, migVec = avg_cluster_freq, vaccTypes = mass_VT, v = 0.1, vacc_time = 0)


#Params of mean model, sf_wide, det fit 2
params_n_vP <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(mass_consensus_presence_absence), Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = as.matrix(mass_consensus_presence_absence[,-1]), sigma_f = 0.2193191513, sigma_w = 0.0007111157, prop_f = 0.3735531590, delta = delta_ranking, m = 0.0052207254, migVec = avg_cluster_freq, vaccTypes = mass_VT, v = 0.1321567425, vacc_time = 0)
```

### Running the model:
```{r}
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)
# this is expecting doubles. I need to work on that.
```

# initial state: 
```{r}
WFmodel_nG_h_vP$state()
```

# running the model for 36, 72 time steps:
```{r}
WFmodel_nG_h_vP$run(36)
WFmodel_nG_h_vP$run(72)
```

```{r fig.height=5, fig.width=7}
par(mfrow=c(1,1))
# dt <- 1
dt <- 1/36
n_particles <- 10L
#WFmodel_nG_h_vP$update_state(pars = params_n_vP, time = 0)
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)


n_times <- 180
n_times <- 73
x <- array(NA, dim = c(WFmodel_nG_h_vP$info()$len, n_particles, n_times))

for (t in seq_len(n_times)) {
  x[ , , t] <- WFmodel_nG_h_vP$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]



par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
if (length(x[,1,1]) <= 8){
  cols <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7") #8 colorblind friendly colors
} else {
  cols <- rainbow(length(x[,1,1]))
}


library(dplyr)
library(zoo)
par(ask = FALSE)
matplot(time, rollmean(x[1,1 , ], k=36, fill=NA), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
  matlines(time, rollmean(x[species,1 , ], k=36, fill=NA), col = cols[species], lty = 1)
}
# or 
 matplot(time,(x[1,1 , ]), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
  matlines(time, (x[species,1 , ]), col = cols[species], lty = 1)
}
#if you want to see all single values, not the monthly rolling mean


legend("bottomright", lwd = 1, col = cols[1:length(x[,1,1])], legend = 1:length(x[,1,1]), bty = "n")
```

# create function for creating lollipop plots
```{r}


library(ggplot2)
library(gridExtra)

make_lollipop_plot <- function(data1, data2, data3, model1, model2, model3){
  
# Create data
          lollipop_data_2001_nVT <- data.frame(
            x=which(mass_VT==0),
            model2001=model1[which(mass_VT==0)] / sum(model1),
            data2001=as.numeric(data1[which(mass_VT==0)] / sum(data1))
          )
          lollipop_data_2001_VT <- data.frame(
            x=which(mass_VT==1),
            model2001=model1[which(mass_VT==1)] / sum(model1),
            data2001=as.numeric(data1[which(mass_VT==1)] / sum(data1))
          )
          lollipop_data_2004_nVT <- data.frame(
            x=which(mass_VT==0),
            model2004=model2[which(mass_VT==0)] / sum(model2),
            data2004=as.numeric(data2[which(mass_VT==0)] / sum(data2))
          )
          lollipop_data_2004_VT <- data.frame(
            x=which(mass_VT==1),
            model2004=model2[which(mass_VT==1)] / sum(model2),
            data2004=as.numeric(data2[which(mass_VT==1)] / sum(data2))
          )
          lollipop_data_2007_nVT <- data.frame(
            x=which(mass_VT==0),
            model2007=model3[which(mass_VT==0)] / sum(model3),
            data2007=as.numeric(data3[which(mass_VT==0)] / sum(data3))
          )
          lollipop_data_2007_VT <- data.frame(
            x=which(mass_VT==1),
            model2007=model3[which(mass_VT==1)] / sum(model3),
            data2007=as.numeric(data3[which(mass_VT==1)] / sum(data3))
          )
          # Change baseline
          lollipop_plot_2001_nVT <- ggplot(lollipop_data_2001_nVT) +
            geom_segment( aes(x=x, xend=x, y=model2001, yend=data2001), color="grey") +
            geom_point( aes(x=x, y=model2001, color="Model non-VT"), size=3 ) +
            geom_point( aes(x=x, y=data2001, color="Data non_VT"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2001 Non-Vaccine Types") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001_nVT$model2001),max(lollipop_data_2001_nVT$data2001),max(lollipop_data_2004_VT$model2004),max(lollipop_data_2004_VT$data2004),max(lollipop_data_2007_nVT$model2007),max(lollipop_data_2007_nVT$data2007)))
          lollipop_plot_2001_VT <- ggplot(lollipop_data_2001_VT) +
            geom_segment( aes(x=x, xend=x, y=model2001, yend=data2001), color="grey") +
            geom_point( aes(x=x, y=model2001, color="Model non-VT"), size=3 ) +
            geom_point( aes(x=x, y=data2001, color="Data non_VT"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2001 Vaccine Types") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001_nVT$model2001),max(lollipop_data_2001_nVT$data2001),max(lollipop_data_2004_VT$model2004),max(lollipop_data_2004_VT$data2004),max(lollipop_data_2007_nVT$model2007),max(lollipop_data_2007_nVT$data2007)))
          lollipop_plot_2004_nVT <- ggplot(lollipop_data_2004_nVT) +
            geom_segment( aes(x=x, xend=x, y=model2004, yend=data2004), color="grey") +
            geom_point( aes(x=x, y=model2004, color="Model"), size=3 ) +
            geom_point( aes(x=x, y=data2004, color="Data"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2004 Non-Vaccine Types") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
ylim(0, max(max(lollipop_data_2001_nVT$model2001),max(lollipop_data_2001_nVT$data2001),max(lollipop_data_2004_VT$model2004),max(lollipop_data_2004_VT$data2004),max(lollipop_data_2007_nVT$model2007),max(lollipop_data_2007_nVT$data2007)))          
          lollipop_plot_2004_VT <- ggplot(lollipop_data_2004_VT) +
            geom_segment( aes(x=x, xend=x, y=model2004, yend=data2004), color="grey") +
            geom_point( aes(x=x, y=model2004, color="Model"), size=3 ) +
            geom_point( aes(x=x, y=data2004, color="Data"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2004 Vaccine Types") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001_nVT$model2001),max(lollipop_data_2001_nVT$data2001),max(lollipop_data_2004_VT$model2004),max(lollipop_data_2004_VT$data2004),max(lollipop_data_2007_nVT$model2007),max(lollipop_data_2007_nVT$data2007))) 
          lollipop_plot_2007_nVT <- ggplot(lollipop_data_2007_nVT) +
            geom_segment( aes(x=x, xend=x, y=model2007, yend=data2007), color="grey") +
            geom_point( aes(x=x, y=model2007, color="Model"), size=3 ) +
            geom_point( aes(x=x, y=data2007, color="Data"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2007 Non-Vaccine Types") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001_nVT$model2001),max(lollipop_data_2001_nVT$data2001),max(lollipop_data_2004_VT$model2004),max(lollipop_data_2004_VT$data2004),max(lollipop_data_2007_nVT$model2007),max(lollipop_data_2007_nVT$data2007)))          
          lollipop_plot_2007_VT <- ggplot(lollipop_data_2007_VT) +
            geom_segment( aes(x=x, xend=x, y=model2007, yend=data2007), color="grey") +
            geom_point( aes(x=x, y=model2007, color="Model"), size=3 ) +
            geom_point( aes(x=x, y=data2007, color="Data"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Legend") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = c(.8,.8),legend.text = element_text(size = 20),legend.title = element_text(size = 20)) +
            ggtitle("2007 Vaccine Types") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001_nVT$model2001),max(lollipop_data_2001_nVT$data2001),max(lollipop_data_2004_VT$model2004),max(lollipop_data_2004_VT$data2004),max(lollipop_data_2007_nVT$model2007),max(lollipop_data_2007_nVT$data2007)))

          grid.arrange(lollipop_plot_2001_nVT + theme(plot.margin = unit(c(.5,0.5,1,0.5), "cm")),lollipop_plot_2004_nVT+ theme(plot.margin = unit(c(.5,0.5,1,0.5), "cm")), lollipop_plot_2007_nVT + theme(plot.margin = unit(c(.5,0.5,1,0.5), "cm")),lollipop_plot_2001_VT + theme(plot.margin = unit(c(.5,0.5,.5,0.5), "cm")), lollipop_plot_2004_VT + theme(plot.margin = unit(c(.5,0.5,.5,0.5), "cm")), lollipop_plot_2007_VT + theme(plot.margin = unit(c(.5,0.5,.5,0.5), "cm")), ncol = 3, nrow=2)
}
```

# create lollipop plot for testing different parameter values manually
```{r}
make_lollipop_plot(data1 = mass_cluster_freq_1, data2 = mass_cluster_freq_2, data3= mass_cluster_freq_3, model1 = x[,1,1], model2 = x[,1,37], model3 = x[,1,73])
```

```{r}
make_lollipop_plot_VTtogether <- function(data1, data2, data3, model1, model2, model3){
  
# Create data
          lollipop_data_2001 <- data.frame(
            x=1:mass_clusters,
            model2001=model1 / sum(model1),
            data2001=as.numeric(data1 / sum(data1))
          )
          lollipop_data_2004 <- data.frame(
            x=1:mass_clusters,
            model2004=model2 / sum(model2),
            data2004=as.numeric(data2 / sum(data2))
          )
          lollipop_data_2007 <- data.frame(
            x=1:mass_clusters,
            model2007=model3 / sum(model3),
            data2007=as.numeric(data3 / sum(data3))
          )
          # Change baseline
          lollipop_plot_2001 <- ggplot(lollipop_data_2001) +
            geom_segment( aes(x=x, xend=x, y=model2001, yend=data2001), color="grey") +
            geom_point( aes(x=x, y=model2001, color="Model non-VT"), size=3 ) +
            geom_point( aes(x=x, y=data2001, color="Data non_VT"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2001") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001$model2001),max(lollipop_data_2001$data2001),max(lollipop_data_2004$model2004),max(lollipop_data_2004$data2004),max(lollipop_data_2007$model2007),max(lollipop_data_2007$data2007)))
          lollipop_plot_2004 <- ggplot(lollipop_data_2004) +
            geom_segment( aes(x=x, xend=x, y=model2004, yend=data2004), color="grey") +
            geom_point( aes(x=x, y=model2004, color="Model"), size=3 ) +
            geom_point( aes(x=x, y=data2004, color="Data"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Group") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = "none") +
            ggtitle("2004") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001$model2001),max(lollipop_data_2001$data2001),max(lollipop_data_2004$model2004),max(lollipop_data_2004$data2004),max(lollipop_data_2007$model2007),max(lollipop_data_2007$data2007))) 
          lollipop_plot_2007 <- ggplot(lollipop_data_2007) +
            geom_segment( aes(x=x, xend=x, y=model2007, yend=data2007), color="grey") +
            geom_point( aes(x=x, y=model2007, color="Model"), size=3 ) +
            geom_point( aes(x=x, y=data2007, color="Data"), size=3 ) +
            scale_color_manual(values = c("#E69F00", "#56B4E9"),
                               guide  = guide_legend(), 
                               name   = "Legend") +
            coord_flip()+
            #theme_ipsum() +
            theme(legend.position = c(.8,.8),legend.text = element_text(size = 20),legend.title = element_text(size = 20)) +
            ggtitle("2007") +
            ylab("Frequency") +
            xlab("Clusters") +
            theme(axis.title  = element_text(size = 20), axis.text = element_text(size = 20), plot.title = element_text(size = 25,hjust = 0.5))  +
            ylim(0, max(max(lollipop_data_2001$model2001),max(lollipop_data_2001$data2001),max(lollipop_data_2004$model2004),max(lollipop_data_2004$data2004),max(lollipop_data_2007$model2007),max(lollipop_data_2007$data2007)))

          grid.arrange(lollipop_plot_2001 + theme(plot.margin = unit(c(.5,0.5,1,0.5), "cm")),lollipop_plot_2004+ theme(plot.margin = unit(c(.5,0.5,1,0.5), "cm")), lollipop_plot_2007 + theme(plot.margin = unit(c(.5,0.5,1,0.5), "cm")), ncol = 3, nrow=1)
}
```

```{r}
make_lollipop_plot_VTtogether(data1 = mass_cluster_freq_1, data2 = mass_cluster_freq_2, data3= mass_cluster_freq_3, model1 = x[,1,1], model2 = x[,1,37], model3 = x[,1,73])
```




### now, the fitting can begin! :-)
```{r}
#install.packages("drat") # -- if you don't have drat installed
drat:::add("ncov-ic")
#install.packages("mcstate")
library(mcstate)
```

```{r}
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
# we have data from 2001, 2004, 2007, so we want 3 (years) * 12 (months) = 36 updates in-between

peripost_mass_cluster_freq <- data.frame("year" = c(1, 2), rbind(mass_cluster_freq_2, mass_cluster_freq_3))
names(peripost_mass_cluster_freq) <- c("year", as.character(1:mass_clusters))
  

# (until now I had 2004 and 2007 there and then in the model that resulted in times 72144 and 72252. does not make sense)
# when changing this back, also change initial_time back to 2001

fitting_mass_data <- mcstate::particle_filter_data(data = peripost_mass_cluster_freq,
                                          time = "year",
                                          rate = 1 / dt,
                                          initial_time = 0)
```

### Likelihood:
```{r}
#bench mark your likelihood function please!
#bench::mark()

# log-likelihood of with Poisson distribution
ll_pois <- function(obs, model) {
  exp_noise <- 1e6

  if (is.na(obs)) {
    # Creates vector of zeros in ll with same length, if no data
    ll_obs <- numeric(length(model))
  } else {
    lambda <- model + rexp(n = length(model), rate = exp_noise)
    ll_obs <- dpois(x = obs, lambda = lambda, log = TRUE)
    #print(model)
  }
  ll_obs
}

combined_compare <- function(state, observed, pars = NULL) {
  result <- 0
  #data_size <- sum(observed[as.character(1:62)])
  # cannot get this to work for now
  # instead I will use this:
  data_size <- sum(mass_cluster_freq_1)
  #model_size <- sum(state[, , drop = TRUE])
  model_size = 15000
  
  for (i in 1:mass_clusters){
    #browser()
    #print(observed[[as.character(i)]])
    #print(state[1+i, , drop = TRUE]/model_size * data_size)
    #print(state[1+i, , drop = TRUE])
    result <- result + ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
    #test_likelihood <- ll_pois(observed[[as.character(i)]], state[1+i, , drop = TRUE]/model_size * data_size)
    #print(result)
  }
  #print(result)
  result
}

#manual usage: combined_compare(WFmodel_nG_h_vP$state(), observed = mass_data[1,])
```

```{r}
#index <- function(info) {
#  list(run = 5L, state = 2:63)
#}
### trying out deterministic particle filter
det_filter <- particle_deterministic$new(data = fitting_mass_data,
                                       model = WF_nG_h_vP,
                                       compare = combined_compare)
```

```{r}
# run determinstic filter
params_n_vP_test <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(mass_consensus_presence_absence), Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = as.matrix(mass_consensus_presence_absence[,-1]), sigma_f = 0.262113847, sigma_w = 0.0539380352, prop_f = 0.374918544, delta = delta_ranking, m = 0.074543360, migVec = avg_cluster_freq, vaccTypes = mass_VT, v = 0.224880313, vacc_time = 1)
params_n_vP_test2 <- list(dt = 1/36, species_no = mass_clusters,  gene_no = nrow(mass_consensus_presence_absence), Pop_ini = as.double(model_start_pop), Pop_eq = as.double(model_start_pop), capacity = sum(model_start_pop), Genotypes = as.matrix(mass_consensus_presence_absence[,-1]), sigma_f = 0.035891894, sigma_w = 0.0859737290, prop_f = 0.137161646, delta = delta_ranking, m = 0.047019561, migVec = avg_cluster_freq, vaccTypes = mass_VT, v = 0.308033413, vacc_time = 1)
testfilter <- det_filter$run(save_history = TRUE, pars = params_n_vP_test2)
```

#Plot particle filter
```{r}
plot_particle_filter <- function(history, true_history, times, obs_end = NULL) {
  if (is.null(obs_end)) {
    obs_end <- max(times)
  }

  par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
  cols <- rainbow(mass_clusters)
  
  matplot(times, (history[2, , -1]), type = "l",
          xlab = "Time", ylab = "Number of individuals",
          col = cols[1], lty = 1, ylim = range(history[2:mass_clusters+1, , -1]))
  for (species in 3:length(history[,1,1])) {
    matlines(times, (history[species, , -1]), col = cols[species-1], lty = 1)
  }  
  for (species in 2:mass_clusters) {
    matpoints(times[1:obs_end], (true_history[1:2,species]), pch = 19, col = cols[species-1])
  }
  legend("left", lwd = 1, col = cols, legend = 1:62, bty = "n")
  
}
scaled_filter_history <- det_filter$history()/15000 * sum(mass_cluster_freq_1)
plot_particle_filter(scaled_filter_history, peripost_mass_cluster_freq,1:2)
```



```{r}
# Using MCMC to infer parameters
#pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- mass_clusters
no_clusters <- mass_clusters
gene_no <- nrow(as.matrix(mass_consensus_presence_absence[,-1]))
#Pop_ini <- cluster_freq_1
#Pop_eq <- cluster_freq_1
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <- as.matrix(mass_consensus_presence_absence[,-1])
#capacity <- sum(cluster_freq_1)
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- mass_VT
vacc_time <- 0
dt <- 1/36
migVec <- avg_cluster_freq

complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt, migVec)
#set_names <- function(x, nms) {
#  names(x) <- nms
#  x
#}
#transform <- set_names(lapply(complex_params, make_transform), complex_params)
make_transform <- function(p) {
  function(theta){
        c(list(Pop_ini = p[1:mass_clusters],
         Pop_eq = p[(mass_clusters +1) : (mass_clusters + mass_clusters)],
         Genotypes = matrix(p[(mass_clusters + mass_clusters + 1): ((mass_clusters + mass_clusters + 1) + (gene_no * species_no) - 1)], nrow = gene_no, ncol = species_no),
         capacity = p[((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 1],
         delta = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2) : (((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no -1)],
         vaccTypes = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) : ((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters -1)],
         species_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters],
         gene_no = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 1],
         vacc_time = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 2],
         dt = p[(((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 3],
         migVec = p[((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4):((((2 * mass_clusters + 1) + (gene_no * species_no) - 1) + 2 + gene_no) + no_clusters + 4 + species_no - 1)]), as.list(theta))
  }
  }

transform <- function(x) {
  make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently. 
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
```

### DETERMINISTIC FITTING

```{r}
# do fitting with deterministic particle filter

mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))

det_filter <- particle_deterministic$new(data = fitting_mass_data,
                                       model = WF_nG_h_vP,
                                       compare = combined_compare)

n_steps <- 1000
n_burnin <- 0


control <- mcstate::pmcmc_control(
    n_steps,
    save_state = TRUE, 
    save_trajectories = TRUE,
    progress = TRUE,
    adaptive_proposal = TRUE,
    n_chains = 2)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))

#plot_particle_filter(det_pmcmc_run$trajectories$state/15000*300, peripost_mass_cluster_freq, 1:2)
library(coda)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
plot(det_mcmc1)


```

```{r}
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 250, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
```

```{r}
#use lollipop plotting function
make_lollipop_plot(data1 = mass_cluster_freq_1, data2 = mass_cluster_freq_2, data3 = mass_cluster_freq_3, model1 = processed_chains$trajectories$state[-1,1,1], model2 = processed_chains$trajectories$state[-1,1,2], model3 = processed_chains$trajectories$state[-1,1,3])

```

```{r}
1 - coda::rejectionRate(det_mcmc1)
# rejection rate atm 0.25 - great!
```

```{r}
# Plot of the four chains on top of each other for the five parameters:
# (inspired by "plot 5" in FitzJohn (plot number in actual paper:6))

cols <- c("#000000","#E69F00", "#56B4E9","#009E73")

# Combine chains in columns for plotting
sigmaf <- cbind(det_pmcmc_run$pars[,'sigma_f'][1:10000], det_pmcmc_run$pars[,'sigma_f'][10001:20000])
sigmaw <- cbind(det_pmcmc_run$pars[,'sigma_w'][1:10000], det_pmcmc_run$pars[,'sigma_w'][10001:20000])
propf <- cbind(det_pmcmc_run$pars[,'prop_f'][1:10000], det_pmcmc_run$pars[,'prop_f'][10001:20000])
mig <- cbind(det_pmcmc_run$pars[,'m'][1:10000], det_pmcmc_run$pars[,'m'][10001:20000])
vacc <- cbind(det_pmcmc_run$pars[,'v'][1:10000], det_pmcmc_run$pars[,'v'][10001:20000])

par(mfrow=c(5,1))
matplot(sigmaf, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "sigma_f", col = cols)
matplot(sigmaw, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "sigma_w", col = cols)
matplot(propf, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "prop_f", col = cols)
matplot(mig, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "m", col = cols)
matplot(vacc, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "v", col = cols)

```



```{r}
det_proposal_matrix <- cov(processed_chains$pars)
#det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
det_proposal_matrix
```

```{r}
det_filter <- particle_deterministic$new(data = fitting_mass_data,
                                       model = WF_nG_h_vP,
                                       compare = combined_compare)

n_steps <- 20000
n_burnin <- 0


control <- mcstate::pmcmc_control(
    n_steps,
    save_state = TRUE, 
    save_trajectories = TRUE,
    progress = TRUE,
    adaptive_proposal = TRUE,
    n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(det_mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))

#plot_particle_filter(det_pmcmc_run$trajectories$state/15000*300, peripost_mass_cluster_freq, 1:2)
library(coda)
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
plot(det_mcmc2)
```

```{r}
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 1000, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
```

```{r}
#use lollipop plotting function
make_lollipop_plot(data1 = mass_cluster_freq_1, data2 = mass_cluster_freq_2, data3 = mass_cluster_freq_3, model1 = processed_chains$trajectories$state[-1,1,1], model2 = processed_chains$trajectories$state[-1,1,2], model3 = processed_chains$trajectories$state[-1,1,3])
```

```{r}
# Plot of the four chains on top of each other for the five parameters:
# (inspired by "plot 5" in FitzJohn (plot number in actual paper:6))

cols <- c("#000000","#E69F00", "#56B4E9","#009E73")

# Combine chains in columns for plotting
sigmaf <- cbind(det_pmcmc_run2$pars[,'sigma_f'][1:10000], det_pmcmc_run2$pars[,'sigma_f'][10001:20000],det_pmcmc_run2$pars[,'sigma_f'][20001:30000], det_pmcmc_run2$pars[,'sigma_f'][30001:40000])
sigmaw <- cbind(det_pmcmc_run2$pars[,'sigma_w'][1:10000], det_pmcmc_run2$pars[,'sigma_w'][10001:20000],det_pmcmc_run2$pars[,'sigma_w'][20001:30000], det_pmcmc_run2$pars[,'sigma_w'][30001:40000])
propf <- cbind(det_pmcmc_run2$pars[,'prop_f'][1:10000], det_pmcmc_run2$pars[,'prop_f'][10001:20000],det_pmcmc_run2$pars[,'prop_f'][20001:30000], det_pmcmc_run2$pars[,'prop_f'][30001:40000])
mig <- cbind(det_pmcmc_run2$pars[,'m'][1:10000], det_pmcmc_run2$pars[,'m'][10001:20000],det_pmcmc_run2$pars[,'m'][20001:30000], det_pmcmc_run2$pars[,'m'][30001:40000])
vacc <- cbind(det_pmcmc_run2$pars[,'v'][1:10000], det_pmcmc_run2$pars[,'v'][10001:20000],det_pmcmc_run2$pars[,'v'][20001:30000], det_pmcmc_run2$pars[,'v'][30001:40000])

par(mfrow=c(5,1))
matplot(sigmaf, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "sigma_f", col = cols)
matplot(sigmaw, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "sigma_w", col = cols)
matplot(propf, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "prop_f", col = cols)
matplot(mig, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "m", col = cols)
matplot(vacc, type = "l", lty = 1, 
        xlab = "Iteration", 
        ylab = "v", col = cols)

```



```{r}
stoch_proposal_matrix <- cov(processed_chains$pars)
stoch_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), det_proposal_matrix, make_transform(complex_params))
stoch_proposal_matrix
```

```{r}
#try doing a stochastic fit with these parameters now

filter <- mcstate::particle_filter$new(data = fitting_mass_data,
                                       model = WF_nG_h_vP,
                                       n_particles = n_particles,
                                       compare = combined_compare,
                                       seed = 1L)


mcmc_pars <- stoch_mcmc_pars
n_particles <- 100
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
    n_steps,
    save_state = TRUE, 
    save_trajectories = TRUE,
    progress = TRUE,
    n_chains = 3)
pmcmc_run <- mcstate::pmcmc(stoch_mcmc_pars, filter, control = control)

#par(mfrow = c(1,1))
#plot_particle_filter(pmcmc_run$trajectories$state, true_history, 1:2)

stoch_mcmc1 <- coda::as.mcmc(cbind(pmcmc_run$probabilities, pmcmc_run$pars))
plot(stoch_mcmc1)
1 - coda::rejectionRate(stoch_mcmc1)
```

```{r}
processed_chains <- mcstate::pmcmc_thin(pmcmc_run, burnin = 100, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
```

```{r}
stoch_proposal_matrix <- cov(processed_chains$pars)
stoch_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0.000001, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), stoch_proposal_matrix, make_transform(complex_params))
stoch_proposal_matrix
```

```{r}
#2nd stochastic fit

filter <- mcstate::particle_filter$new(data = fitting_mass_data,
                                       model = WF_nG_h_vP,
                                       n_particles = n_particles,
                                       compare = combined_compare,
                                       seed = 1L)


mcmc_pars <- stoch_mcmc_pars
n_particles <- 100
n_steps <- 1000
n_burnin <- 0
control <- mcstate::pmcmc_control(
    n_steps,
    save_state = TRUE, 
    save_trajectories = TRUE,
    progress = TRUE,
    n_chains = 3)
pmcmc_run2 <- mcstate::pmcmc(stoch_mcmc_pars, filter, control = control)

#par(mfrow = c(1,1))
#plot_particle_filter(pmcmc_run$trajectories$state, true_history, 1:2)

stoch_mcmc2 <- coda::as.mcmc(cbind(pmcmc_run2$probabilities, pmcmc_run2$pars))
plot(stoch_mcmc2)
1 - coda::rejectionRate(stoch_mcmc2)
```

```{r}
processed_chains <- mcstate::pmcmc_thin(pmcmc_run2, burnin = 200, thin = 1)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
```


```{r}
#use lollipop plotting function
make_lollipop_plot(data1 = mass_cluster_freq_1, data2 = mass_cluster_freq_2, data3 = mass_cluster_freq_3, model1 = processed_chains$trajectories$state[-1,1,1], model2 = processed_chains$trajectories$state[-1,1,2], model3 = processed_chains$trajectories$state[-1,1,3])
```

#corander values:
#0.052, 0.039, 0.031, 0.112, 0.073, 0.068, 0.06, 0.073, 0.074, 0, 0.01, 0.022, 0.037, 0.039, 0.0331, 0.022, 0.014, 0.024, 0, 0.015, 0.031, 0, 0.004, 0.018, 0.16, 0.17, 0.169, 0.09, 0.089, 0.086, 0.015, 0.03, 0.035, 0.021, 0.074, 0.087, 	0.015, 0.014, 0.013, 0.054, 0.01, 0.008, 0.047, 0.015, 0.008, 	0.047, 0.035, 0.031, 	0.023, 0.25, 0.019, 	0.009, 0.011, 0.12, 	0.047, 0.021, 0.012, 	0.016, 0.023, 0.019, 	0, 0.17, 0.22, 	0.009, 0.026, 0.026, 0.039, 0.01, 0.005, 0.017, 0.019, 0.2, 0.04, 0.017, 0.005, 0, 0.002, 0.005, 0, 0.005, 0.009, 	0, 0.005, 0.009, 0.017, 0.016, 0.014, 0.024, 0.0001, 0, 0.01, 0.012, 0.009, 0.01, 0.008, 0.003, 0, 0.008, 0.01, 0.01, 0.012, 0.013, 0, 0.008, 0.014, 0, 0.008, 0.014, 0, 0.008, 0.01, 0, 0.008, 0.018, 0.01, 0.012, 0.016, 0.01, 0.007, 0.007, 0.01, 0.008, 0.004

```{r}
corander_pred <- c(0.052, 0.039, 0.031, 0.112, 0.073, 0.068, 0.06, 0.073, 0.074, 0, 0.01, 0.022, 0.037, 0.039, 0.0331, 0.022, 0.014, 0.024, 0, 0.015, 0.031, 0, 0.004, 0.018, 0.16, 0.17, 0.169, 0.09, 0.089, 0.086, 0.015, 0.03, 0.035, 0.021, 0.074, 0.087, 	0.015, 0.014, 0.013, 0.054, 0.01, 0.008, 0.047, 0.015, 0.008, 	0.047, 0.035, 0.031, 	0.023, 0.025, 0.019, 	0.009, 0.011, 0.012, 	0.047, 0.021, 0.012, 	0.016, 0.023, 0.019, 	0, 0.017, 0.022, 	0.009, 0.026, 0.026, 0.039, 0.01, 0.005, 0.017, 0.019, 0.02, 0.04, 0.017, 0.005, 0, 0.002, 0.005, 0, 0.005, 0.009, 	0, 0.005, 0.009, 0.017, 0.016, 0.014, 0.024, 0.0001, 0, 0.01, 0.012, 0.009, 0.01, 0.008, 0.003, 0, 0.008, 0.01, 0.01, 0.012, 0.013, 0, 0.008, 0.014, 0, 0.008, 0.014, 0, 0.008, 0.01, 0, 0.008, 0.018, 0.01, 0.012, 0.016, 0.01, 0.007, 0.007, 0.01, 0.008, 0.004)
ind1 <- seq(from=1, to=length(corander_pred-2), by = 3)
ind2 <- seq(from=2, to=length(corander_pred-1), by = 3)
ind3 <- seq(from=3, to=length(corander_pred), by = 3)
corander_pred_1 <- corander_pred[ind1]
corander_pred_2 <- corander_pred[ind2]
corander_pred_3 <- corander_pred[ind3]
make_lollipop_plot(data1 = mass_cluster_freq_1, data2 = mass_cluster_freq_2, data3 = mass_cluster_freq_3, model1 = corander_pred_1, model2 = corander_pred_2, model3 = corander_pred_3)
make_lollipop_plot(data1 = corander_pred_1, data2 = corander_pred_2, data3 = corander_pred_3, model1 = processed_chains$trajectories$state[-1,1,1], model2 = processed_chains$trajectories$state[-1,1,2], model3 = processed_chains$trajectories$state[-1,1,3])
```

```{r}
par(mfrow=c(3,1))
plot(1:length(mass_cluster_freq_1), mass_cluster_freq_1/sum(mass_cluster_freq_1), col = "#E69F00", pch = 19)
points(1:length(corander_pred_1), corander_pred_1/sum(corander_pred_1), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]), col = "#56B4E9", pch = 19)
plot(1:length(mass_cluster_freq_1), mass_cluster_freq_2/sum(mass_cluster_freq_2), col = "#E69F00", pch = 19 )
points(1:length(corander_pred_1), corander_pred_2/sum(corander_pred_2), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]), col = "#56B4E9", pch = 19)
plot(1:length(mass_cluster_freq_1), mass_cluster_freq_3/sum(mass_cluster_freq_3), col = "#E69F00", pch = 19 )
points(1:length(corander_pred_1), corander_pred_3/sum(corander_pred_3), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]), col = "#56B4E9", pch = 19)
```

```{r}
par(mfrow=c(3,1))
plot(1:length(corander_pred_1), corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1)), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1), col = "#56B4E9", pch = 19)
lines(1:length(processed_chains$trajectories$state[-1,1,1]),(processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1)), col = "#56B4E9", pch = 19)
lines(1:length(processed_chains$trajectories$state[-1,1,1]),(corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1))), col = "#009E73", pch = 19)
abline(h=0,col="black",lty=2)
plot(1:length(corander_pred_1), corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2)), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2), col = "#56B4E9", pch = 19)
lines(1:length(processed_chains$trajectories$state[-1,1,1]),(processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2)), col = "#56B4E9", pch = 19)
lines(1:length(processed_chains$trajectories$state[-1,1,1]),(corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2))), col = "#009E73", pch = 19)
abline(h=0,col="black",lty=2)
plot(1:length(corander_pred_1), corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3)), col = "#009E73", pch = 19, ylim = c(-0.025, 0.035))
points(1:length(processed_chains$trajectories$state[-1,1,1]),processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3), col = "#56B4E9", pch = 19)
lines(1:length(processed_chains$trajectories$state[-1,1,1]),(processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3)), col = "#56B4E9", pch = 19)
lines(1:length(processed_chains$trajectories$state[-1,1,1]),(corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3))), col = "#009E73", pch = 19)
abline(h=0,col="black",lty=2)
```

```{r}
par(mfrow=c(3,1))
plot(1:length(corander_pred_1), abs(corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1))), col = "#009E73", pch =19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1)), col = "#56B4E9", pch = 19)

plot(1:length(corander_pred_1), abs(corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2))), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2)), col = "#56B4E9", pch = 19)

plot(1:length(corander_pred_1), abs(corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3))), col = "#009E73", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3)), col = "#56B4E9", pch = 19)

```

```{r}
par(mfrow=c(3,1))
plot(1:length(corander_pred_1), abs(corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1))), col = "#009E73", lty =1, type = "line")
lines(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1)), col = "#56B4E9", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1)), col = "#56B4E9", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1))), col = "#009E73", pch = 19)

plot(1:length(corander_pred_1), abs(corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2))), col = "#009E73", lty =1, type = "line")
lines(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2)), col = "#56B4E9", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2)), col = "#56B4E9", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2))), col = "#009E73", pch = 19)

plot(1:length(corander_pred_1), abs(corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3))), col = "#009E73", lty =1, type = "line", ylim = c(0,0.03))
lines(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3)), col = "#56B4E9", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3)), col = "#56B4E9", pch = 19)
points(1:length(processed_chains$trajectories$state[-1,1,1]),abs(corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3))), col = "#009E73", pch = 19)
```

```{r}
sum(abs(corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1))))
#[1] 0.05632183
sum(abs(processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1)))
#[1] 0.04999137

sum(abs(corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2))))
#[1] 0.3480558
sum(abs(processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2)))
#[1] 0.2471812

sum(abs(corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3))))
#[1] 0.3279665
sum(abs(processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3)))
#[1] 0.2411098

# I am doing better in every single time point!

```
# I could also calculate the sum of squares instead 
```{r}
sum((corander_pred_1/sum(corander_pred_1) - (mass_cluster_freq_1/sum(mass_cluster_freq_1)))^2)
#[1] 0.0001968602
sum((processed_chains$trajectories$state[-1,1,1]/sum(processed_chains$trajectories$state[-1,1,1]) - mass_cluster_freq_1/sum(mass_cluster_freq_1))^2)
#detFit:
#[1] 0.0001183908
#stochFit:
#0.0001183908
sum((corander_pred_2/sum(corander_pred_2) - (mass_cluster_freq_2/sum(mass_cluster_freq_2)))^2)
#[1] 0.006980254
sum((processed_chains$trajectories$state[-1,1,2]/sum(processed_chains$trajectories$state[-1,1,2]) - mass_cluster_freq_2/sum(mass_cluster_freq_2))^2)
#detFit:
#[1] 0.002701713
#stochFit:
#0.003667608

sum((corander_pred_3/sum(corander_pred_3) - (mass_cluster_freq_3/sum(mass_cluster_freq_3)))^2)
#[1] 0.003858311
sum((processed_chains$trajectories$state[-1,1,3]/sum(processed_chains$trajectories$state[-1,1,3]) - mass_cluster_freq_3/sum(mass_cluster_freq_3))^2)
#detFit:
#[1] 0.003677562
#stochFit:
# 0.003304077

#I don't think the stochastic fit has converged yet (it was three chains, 1000steps each). I will need more than 1000 steps.

```

