list(Pop_ini = p[1:62],
Pop_eq = p[63 : 124],
Genotypes = matrix(p[125 : (125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1)], nrow = gene_no, ncol = no_clusters),
capacity = p[(125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) +1],
delta = p[((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) : (((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no -1)],
vaccTypes = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no) : (((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters -2)],
species_no = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters -1)],
gene_no = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters)],
vacc_time = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 1],
dt = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 2])
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.1, max = 0.5), mcstate::pmcmc_parameter("sigma_w", 0.005, min = 0, max = 0.05), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
# Using MCMC to infer parameters
#pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- no_clusters
gene_no <- nrow(cluster_gene_presence_absence)
#Pop_ini <- cluster_freq_1
#Pop_eq <- cluster_freq_1
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <-matrix_cluster_gene_presence_absence
#capacity <- sum(cluster_freq_1)
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- isVT_vec
vacc_time <- 0
dt <- 1/36
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt)
#set_names <- function(x, nms) {
#  names(x) <- nms
#  x
#}
#transform <- set_names(lapply(complex_params, make_transform), complex_params)
make_transform <- function(p) {
function(theta){
list(Pop_ini = p[1:62],
Pop_eq = p[63 : 124],
Genotypes = matrix(p[125 : (125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1)], nrow = gene_no, ncol = no_clusters),
capacity = p[(125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) +1],
delta = p[((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) : (((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no -1)],
vaccTypes = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no) : (((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters -2)],
species_no = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters -1)],
gene_no = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters)],
vacc_time = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 1],
dt = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 2], as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
n_steps <- 500
n_burnin <- 200
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0.1, max = 0.5), mcstate::pmcmc_parameter("sigma_w", 0.005, min = 0, max = 0.05), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
params_n_vP
length(complex_params)
125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 2
(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 2
theta
mcmc_pars
mcmc_pars$initial()
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
det_filter <- particle_deterministic$new(data = fitting_mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
mcmc_pars
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 2)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
make_transform(complex_params)
# Using MCMC to infer parameters
#pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
#pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
pmcmc_sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1)
pmcmc_sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1)
pmcmc_prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
pmcmc_m <- mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1)
pmcmc_v <- mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)
species_no <- no_clusters
gene_no <- nrow(cluster_gene_presence_absence)
#Pop_ini <- cluster_freq_1
#Pop_eq <- cluster_freq_1
Pop_ini <- model_start_pop
Pop_eq <- model_start_pop
Genotypes <-matrix_cluster_gene_presence_absence
#capacity <- sum(cluster_freq_1)
capacity <- sum(model_start_pop)
delta <- delta_ranking
vaccTypes <- isVT_vec
vacc_time <- 0
dt <- 1/36
complex_params <- c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time, dt)
#transform <- set_names(lapply(complex_params, make_transform), complex_params)
make_transform <- function(p) {
function(theta){
c(list(Pop_ini = p[1:62],
Pop_eq = p[63 : 124],
Genotypes = matrix(p[125 : (125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1)], nrow = gene_no, ncol = no_clusters),
capacity = p[(125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) +1],
delta = p[((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) : (((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no -1)],
vaccTypes = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no) : (((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters -2)],
species_no = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters -1)],
gene_no = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters)],
vacc_time = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 1],
dt = p[(((125 + (nrow(matrix_cluster_gene_presence_absence) * ncol(matrix_cluster_gene_presence_absence))-1) + 2) + gene_no + 1 + no_clusters) + 2]), as.list(theta))
}
}
transform <- function(x) {
make_transform(complex_params)}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
#mcmc_pars <- mcstate::pmcmc_parameters$new(list(pmcmc_sigma_f, pmcmc_sigma_w, pmcmc_prop_f, pmcmc_m, pmcmc_v), proposal_matrix, transform)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 1), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
#= make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
#mcmc_pars$names()
#mcmc_pars$model(mcmc_pars$initial())
mcmc_pars$initial()
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
n_steps <- 500
n_burnin <- 200
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 2)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
plot_particle_filter(pmcmc_run$trajectories$state, true_history, 1:2)
library(coda)
det_mcmc1 <- coda::as.mcmc(cbind(pmcmc_run$probabilities, pmcmc_run$pars))
plot(det_mcmc1)
processed_chains <- mcstate::pmcmc_thin(pmcmc_run, burnin = n_burnin, thin = 2)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
plot(det_mcmc1)
summary(det_mcmc1)
coda::effectiveSize(mcmc1)
coda::effectiveSize(det_mcmc1)
1 - coda::rejectionRate(det_mcmc1)
n_steps <- 1000
n_burnin <- 200
proposal_matrix <- diag(x=c(0.001, 0.001, 0.01, 0.001, 0.01), nrow = 5, ncol = 5)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", 0.1432, min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", 0.0011, min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1), mcstate::pmcmc_parameter("m", 0.03, min = 0, max = 0.2), mcstate::pmcmc_parameter("v", 0.05, min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
n_particles <- 100
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
plot_particle_filter(pmcmc_run$trajectories$state, true_history, 1:2)
library(coda)
det_mcmc1 <- coda::as.mcmc(cbind(pmcmc_run$probabilities, pmcmc_run$pars))
summary(det_mcmc1)
plot(det_mcmc1)
processed_chains <- mcstate::pmcmc_thin(pmcmc_run, burnin = 200)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
coda::effectiveSize(det_mcmc1)
1 - coda::rejectionRate(det_mcmc1)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(hrbrthemes)
# Create data
lollipop_data_2004 <- data.frame(
x=1:no_clusters,
model2004=pmcmc_run$trajectories$state[2:63,1,2]/sum(pmcmc_run$trajectories$state[2:63,1,2]),
data2004=as.numeric(true_history[1,2:63])/sum(as.numeric(true_history[1,2:63]))
)
lollipop_data_2007 <- data.frame(
x=1:no_clusters,
model2007=pmcmc_run$trajectories$state[2:63,1,3]/sum(pmcmc_run$trajectories$state[2:63,1,3]),
data2007=as.numeric(true_history[2,2:63])/sum(as.numeric(true_history[2,2:63]))
)
# Change baseline
lollipop_plot_2004 <- ggplot(lollipop_data_2004) +
geom_segment( aes(x=x, xend=x, y=model2004, yend=data2004), color="grey") +
geom_point( aes(x=x, y=model2004, color="Model"), size=3 ) +
geom_point( aes(x=x, y=data2004, color="Data"), size=3 ) +
scale_color_manual(values = c("#E69F00", "#56B4E9"),
guide  = guide_legend(),
name   = "Group") +
coord_flip()+
theme_ipsum() +
theme(legend.position = "none") +
xlab("") +
ylab("Value of Y") +
ylim(0, max(max(lollipop_data_2004$model2004),max(lollipop_data_2004$data2004),max(lollipop_data_2007$model2007),max(lollipop_data_2007$data2007)))
lollipop_plot_2007 <- ggplot(lollipop_data_2007) +
geom_segment( aes(x=x, xend=x, y=model2007, yend=data2007), color="grey") +
geom_point( aes(x=x, y=model2007, color="Model"), size=3 ) +
geom_point( aes(x=x, y=data2007, color="Data"), size=3 ) +
scale_color_manual(values = c("#E69F00", "#56B4E9"),
guide  = guide_legend(),
name   = "Group") +
coord_flip()+
theme_ipsum() +
theme(legend.position = c(.8,.8)) +
xlab("") +
ylab("Value of Y") +
ylim(0, max(max(lollipop_data_2004$model2004),max(lollipop_data_2004$data2004),max(lollipop_data_2007$model2007),max(lollipop_data_2007$data2007)))
grid.arrange(lollipop_plot_2004, lollipop_plot_2007, ncol = 2)
#what do I learn from this? maybe that my model is making the bigger clusters too big and the smaller ones too small? So stochastic dying of the population is an issue.
#First Lollipop plot of a tuned model fit run. You can see that the model consistently overestimates the size of the big clusters and underestimates the size of the small clusters.
#This can be due to the fact that we are handling such small numbers here.
#I should maybe fit to the frequencies and not the absolute numbers and make sure that the start is being sampled, also for the fitting.
# A quick fix could be to artificially increase the data set numbers.
parameter_mean_hpd[1]
proposal_matrix <- cov(pmcmc_run$pars)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.1, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 0.1), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), proposal_matrix, transform)
proposal_matrix
proposal_matrix <- cov(pmcmc_run$pars)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.1, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 0.1), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
proposal_matrix
n_steps <- 5000
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 4)
pmcmc_tuned_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
# runs in 4 minutes per chain right now
det_mcmc2 <- coda::as.mcmc(cbind(
pmcmc_tuned_run$probabilities, pmcmc_tuned_run$pars))
#par(mfrow = c(1,1))
#plot_particle_filter(pmcmc_tuned_run$trajectories$state, true_history, 1:2)
summary(det_mcmc2)
plot(det_mcmc2)
coda::effectiveSize(mcmc2)
# log_prior log_likelihood  log_posterior        sigma_f        sigma_w         prop_f              m              v
#     0.000000       6.211637       6.211637       2.956989       1.012543       3.381379       1.946453       1.655769
1 - coda::rejectionRate(mcmc2)
# log_prior log_likelihood  log_posterior        sigma_f        sigma_w         prop_f              m              v
#   0.00000000     0.01301301     0.01301301     0.01301301     0.01301301     0.01301301     0.01301301     0.01301301
# oh oh
# acceptance rate is even worse
# and the log prior is constantly 0, I am sure that is the main issue
plot_particle_filter(pmcmc_tuned_run$trajectories$state/15000*300, true_history, 1:2)
# hmm, not a great fit yet
# most of the above about fitting is taken from https://mrc-ide.github.io/mcstate/articles/sir_models.html
# do fitting with deterministic particle filter
#n_particles <- 20
processed_chains <- mcstate::pmcmc_thin(pmcmc_tuned_run, burnin = 200)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
processed_chains <- mcstate::pmcmc_thin(pmcmc_tuned_run, burnin = 200)
parameter_mean_hpd <- apply(processed_chains$pars, 2, mean)
parameter_mean_hpd
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 1), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.1), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 1)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
n_steps <- 5000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 2)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
library(coda)
det_mcmc1 <- coda::as.mcmc(cbind(det_pmcmc_run$probabilities, det_pmcmc_run$pars))
summary(det_mcmc1)
plot(det_mcmc1)
# I currently have an acceptance rate of 1. WHY?!
# my acceptance rate is way too high
# the values of my likelihood do not really change.
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run, burnin = 200)
parameter_mean <- apply(processed_chains$pars, 2, mean)
parameter_mean
processed_chains
processed_chains$pars
det_pmcmc_run
processed_chains
processed_chains$chain
#exlude 3rd because that is weird
processed_chainred <- processed_chains[-(9601:14400)]
processed_chainred
parameter_mean <- apply(processed_chainred$pars, 2, mean)
parameter_mean
parameter_mean <- apply(processed_chains$pars, 2, mean)
parameter_mean
det_proposal_matrix <- cov(det_pmcmc_run$pars)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 0.22), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
det_proposal_matrix <- cov(det_pmcmc_run$pars)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
det_proposal_matrix
#try doing a stochastic fit with these parameters now
#det_mcmc_pars
n_particles <- 100
n_steps <- 500
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 1)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
par(mfrow = c(1,1))
plot_particle_filter(pmcmc_run$trajectories$state, true_history, 1:2)
stoch_mcmc1 <- coda::as.mcmc(cbind(pmcmc_run$probabilities, pmcmc_run$pars))
summary(stoch_mcmc1)
plot(stoch_mcmc1)
stoch_proposal_matrix <- cov(pmcmc_run$pars)
processed_chains <- mcstate::pmcmc_thin(pmcmc_run, burnin = 200)
parameter_mean <- apply(processed_chains$pars, 2, mean)
parameter_mean
stoch_proposal_matrix <- cov(pmcmc_run$pars)
stoch_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean[1], min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean[5], min = 0, max = 0.5)), stoch_proposal_matrix, transform)
stoch_proposal_matrix
#second stoch run
mcmc_pars <- stoch_mcmc_pars
n_particles <- 100
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 2)
pmcmc_run2 <- mcstate::pmcmc(mcmc_pars, filter, control = control)
stoch_proposal_matrix <- cov(pmcmc_run$pars)
stoch_mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean[1], min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean[5], min = 0, max = 0.5)), stoch_proposal_matrix, make_transform(complex_params))
stoch_proposal_matrix
#second stoch run
mcmc_pars <- stoch_mcmc_pars
n_particles <- 100
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
n_chains = 2)
pmcmc_run2 <- mcstate::pmcmc(mcmc_pars, filter, control = control)
stoch_mcmc2 <- coda::as.mcmc(cbind(pmcmc_run2$probabilities, pmcmc_run2$pars))
summary(stoch_mcmc2)
plot(stoch_mcmc2)
parameter_mean <- apply(pmcmc_run2$pars, 2, mean)
parameter_mean
det_proposal_matrix <- cov(det_pmcmc_run$pars)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean_hpd[1], min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean_hpd[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean_hpd[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean_hpd[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean_hpd[5], min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
det_proposal_matrix
# do fitting with deterministic particle filter
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
n_steps <- 10000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
summary(det_mcmc2)
plot(det_mcmc2)
1 - coda::rejectionRate(det_mcmc2)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 200)
parameter_mean <- apply(processed_chains$pars, 2, mean)
parameter_mean
det_proposal_matrix <- cov(det_pmcmc_run$pars)
mcmc_pars <- mcstate::pmcmc_parameters$new(list(mcstate::pmcmc_parameter("sigma_f", parameter_mean[1], min = 0.075, max = 1), mcstate::pmcmc_parameter("sigma_w", parameter_mean[2], min = 0, max = 0.0749), mcstate::pmcmc_parameter("prop_f", parameter_mean[3], min = 0, max = 1), mcstate::pmcmc_parameter("m", parameter_mean[4], min = 0, max = 0.2), mcstate::pmcmc_parameter("v", parameter_mean[5], min = 0, max = 0.5)), proposal_matrix, make_transform(complex_params))
det_proposal_matrix
# do fitting with deterministic particle filter
det_filter <- particle_deterministic$new(data = mass_data,
model = WF_nG_h_vP,
compare = combined_compare)
n_steps <- 20000
n_burnin <- 0
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE,
adaptive_proposal = TRUE,
n_chains = 4)
det_pmcmc_run2 <- mcstate::pmcmc(mcmc_pars, det_filter, control = control)
par(mfrow = c(1,1))
det_mcmc2 <- coda::as.mcmc(cbind(det_pmcmc_run2$probabilities, det_pmcmc_run2$pars))
summary(det_mcmc2)
plot(det_mcmc2)
1 - coda::rejectionRate(det_mcmc2)
processed_chains <- mcstate::pmcmc_thin(det_pmcmc_run2, burnin = 200)
parameter_mean <- apply(processed_chains$pars, 2, mean)
parameter_mean
