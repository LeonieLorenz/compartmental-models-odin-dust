---
title: "Wright Fisher Model for Massachusetts dataset"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sir_models}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: inline
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
lang_output <- function(x, lang) {
  cat(c(sprintf("```%s", lang), x, "```"), sep = "\n")
}
cc_output <- function(x) lang_output(x, "cc")
r_output <- function(x) lang_output(x, "r")
plain_output <- function(x) lang_output(x, "plain")
```

# Stochastic Lotka Volterra model definition


$$\begin{align*}
\frac{dR}{dt} &= \alpha R -\beta RC \\
\frac{dC}{dt} &= \delta \beta RC - \gamma C \\
\end{align*}$$

$R$ is the number of prey, $C$ is the number of predators.$\alpha$ is the birth rate of the prey, $\beta$ is the kill rate, $\gamma$ is the death rate of the predators and $\delta$ describes how much a predator benefits from killing prey.

Discretising this model in time steps of width $dt$ gives the following update equations for each time step:

$$\begin{align*}
R_{t+1} &= R_t - n_{RC} + n_R \\
C_{t+1} &= C_t + \delta n_{RC}  - n_C
\end{align*}$$

where
$$\begin{align*}
n_{R} &\sim B(R, 1 - e^{-\alpha \cdot dt}) \\
n_{RC} &\sim B(R, 1 - e^{-\beta C \cdot dt}) \\
n_{C} &\sim B(C, 1 - e^{-\gamma \cdot dt})
\end{align*}$$

## Implementing the SIR model using [`odin.dust`](https://mrc-ide.github.io/odin.dust/)

The above equations can straightforwardly be written out using the odin DSL:

```{r odin_sir, echo = FALSE, results = "asis"}
r_output(readLines(file.path("WrightFisher_nGenotypes_haploid_PopsizeVariablePois.R")))
```

This is converted to a C++ dust model, and compiled into a library in a single step, using [`odin.dust`](https://mrc-ide.github.io/odin.dust/). Save the above code as a file named `sir.R`. File names must not contain special characters.

```{r}
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
```

```{r}
WF_nG_h_vP <- odin.dust::odin_dust("WrightFisher_nGenotypes_haploid_PopsizeVariablePois.R")
```

### READING IN DATA
### 1) Cluster information from PopPUNK
### 2) Gene presence absence matrix from ggCaller

```{r}
# reading in the cluster produced by PopPUNK
clusters <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/refined_modelfitk3_clusters.csv")
no_clusters <- max(clusters[,2]) # number of clusters in dataset
```

```{r}
# reading in the gene presence absence matrix produced by ggCaller
gene_presence_absence <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/gene_presence_absence.csv", header=FALSE)

# converting the gene presence absence matrix into a boolean df (0 = gene not present, 1 = gene present)
convert_to_bool <- function(x){
  if (x=="") 0 else 1
}
bool_gene_presence_absence <- gene_presence_absence

for (i in 4:length(bool_gene_presence_absence[1,])) {
  bool_gene_presence_absence[,i] <- unlist(lapply(bool_gene_presence_absence[,i], FUN =  convert_to_bool))
}
bool_gene_presence_absence[1,] <- gene_presence_absence[1,]
```

```{r}
# calculate frequency of genes to only keep those which appear in 5-95% of the genomes
gene_freq <- rep(0, nrow(bool_gene_presence_absence)-1)
for (i in 1:length(gene_freq)) {
  gene_freq[i] <- sum(as.integer(bool_gene_presence_absence[i+1,4:ncol(bool_gene_presence_absence)]))
}
gene_freq <- gene_freq / (length(bool_gene_presence_absence[2,])-3)

# create a dataframe that only contains the genes that appear in 5-95% of the genomes
filtered_bool_gene_presence_absence <- data.frame(matrix(nrow = 0, ncol = length(bool_gene_presence_absence[1,])))

for (i in 1:length(gene_freq)){
  if (0.05 < gene_freq[i] & gene_freq[i] < 0.95 ){
    filtered_bool_gene_presence_absence[nrow(filtered_bool_gene_presence_absence)+1,] <- bool_gene_presence_absence[i+1,]
  }
}
colnames(filtered_bool_gene_presence_absence) <- bool_gene_presence_absence[1,]
rownames(filtered_bool_gene_presence_absence) <- 1:nrow(filtered_bool_gene_presence_absence)
```

```{r}
### make consensus genome for clusters
# attempt 1: always let majority decide (if more than 50% in the cluster don't have gene then 0, else 1)
# should be easy to do with median

cluster_gene_presence_absence <- data.frame(matrix(nrow = nrow(filtered_bool_gene_presence_absence), ncol = no_clusters+3))
colnames(cluster_gene_presence_absence)[1:3] <- colnames(filtered_bool_gene_presence_absence)[1:3]
cluster_gene_presence_absence[1:3] <- filtered_bool_gene_presence_absence[1:3]
colnames(cluster_gene_presence_absence)[4:ncol(cluster_gene_presence_absence)] <- 1:no_clusters

mean_cluster_gene_p_a <- cluster_gene_presence_absence # this is just to assess how valid it is to make consensus genomes

for (i in 1:no_clusters){
  curr_cluster <- subset(clusters, clusters$Cluster == i)[,1] # select all genomes in cluster i
  curr_genomes <- as.matrix(filtered_bool_gene_presence_absence[,curr_cluster])
  for (j in 1:nrow(filtered_bool_gene_presence_absence)){
    cluster_gene_presence_absence[j,i+3] <- as.double(median(as.integer(curr_genomes[j,])))
    mean_cluster_gene_p_a[j,i+3] <-(as.double(mean(as.integer(curr_genomes[j,]))))
  }
}
matrix_cluster_gene_presence_absence <- as.matrix((cluster_gene_presence_absence[,4:ncol(cluster_gene_presence_absence)]))

### this is just to have a look at the within-cluster diversity
matrix_mean_cluster_gene_presence_absence <- as.matrix((mean_cluster_gene_p_a[,4:ncol(mean_cluster_gene_p_a)]))
par(mfrow=c(1,1))
plot(1:nrow(matrix_mean_cluster_gene_presence_absence), matrix_mean_cluster_gene_presence_absence[,1], pch=20)
for (clust in 2:length(matrix_mean_cluster_gene_presence_absence[1,])){
  points(matrix_mean_cluster_gene_presence_absence[,clust], pch=20)
}

# well, I'd say that many, many genes are still quite diversely present within the same cluster
# that suggest that taking one consensus genome per cluster might not work


# attempt 2: record relative frequencies. Probably not advantageous.
# attempt 3: keep track of all existing variants. This can be done later
```

```{r}
#calculate the frequency of the gene clusters
cluster_freq <- rep(0,no_clusters)
for (i in 1:no_clusters){
  cluster_freq[i] <- length(subset(clusters, clusters$Cluster == i)[,1])
}
#cluster_freq <- cluster_freq / length(clusters[,1])
# I think I don't want frequency but rather the absolute numbers?
```

```{r}
#need the information of when probes were taken
accNo_to_filename <- read.delim("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/filereport_read_run_PRJEB2632_tsv.txt")
accNo_to_filename <- accNo_to_filename[,c(1,8)]
accNo_to_filename[,3] <- matrix(unlist(strsplit(accNo_to_filename[,2],"/")), ncol=6, byrow = TRUE)[,6]
accNo_to_filename[,3] <- matrix(unlist(strsplit(accNo_to_filename[,3],"[.]")), ncol=2, byrow = TRUE)[,1]
accNo_to_filename <- accNo_to_filename[,c(1,3)]
colnames(accNo_to_filename) <- c(colnames(accNo_to_filename)[1], "filenames")
accNoToFilename <- c()
for (i in 1:nrow(accNo_to_filename)){
  accNoToFilename[as.character(accNo_to_filename[i,2])]<- accNo_to_filename[i,1] 
}
library(readxl)
Croucher_seqYears <- read_excel("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/Croucher_41588_2013_BFng2625_MOESM28_ESM.xlsx")
Croucher_seqYears <- Croucher_seqYears[,c(1,5)]
sequenceYear <- c()
for (i in 1:nrow(Croucher_seqYears)){
  sequenceYear[as.character(Croucher_seqYears[i,1])]<- Croucher_seqYears[i,2] 
}
```


```{r}
# add year to the clusters data set
clusters$seqYear <- rep(0, nrow(clusters))
for (i in 1:nrow(clusters)){
  clusters$seqYear[i] <- sequenceYear[accNoToFilename[clusters$Taxon[i]]]
}
```

```{r}
#calculate the frequency of the gene clusters and year
cluster_freq_1 <- rep(0,no_clusters)
cluster_freq_2 <- rep(0,no_clusters)
cluster_freq_3 <- rep(0,no_clusters)
for (i in 1:no_clusters){
  cluster_freq_1[i] <- length(subset(subset(clusters, clusters$Cluster == i), subset(clusters, clusters$Cluster == i)$seqYear == 2001)[,1])
  cluster_freq_2[i] <- length(subset(subset(clusters, clusters$Cluster == i), subset(clusters, clusters$Cluster == i)$seqYear == 2004)[,1])
  cluster_freq_3[i] <- length(subset(subset(clusters, clusters$Cluster == i), subset(clusters, clusters$Cluster == i)$seqYear == 2007)[,1])
}

# make a data frame that contains this information
library(dplyr)

fitting_cluster_freq_df <- data.frame("year" = c(2001, 2004, 2007), rbind(cluster_freq_1, cluster_freq_2, cluster_freq_3))
names(fitting_cluster_freq_df) <- c("year", as.character(1:62))

```

```{r}
#plot gene freqs
data_gene_freq_1_m <-  matrix_cluster_gene_presence_absence * cluster_freq_1
data_gene_freq_1 <- rep(0, length(data_gene_freq_1_m[,1]))
for (i in 1:length(data_gene_freq_1_m[,1])){
  data_gene_freq_1[i] <- sum(data_gene_freq_1_m[i,1:62])
}
data_gene_freq_2_m <-  matrix_cluster_gene_presence_absence * cluster_freq_2
data_gene_freq_2 <- rep(0, length(data_gene_freq_2_m[,1]))
for (i in 1:length(data_gene_freq_2_m[,1])){
  data_gene_freq_2[i] <- sum(data_gene_freq_2_m[i,1:62])
}
data_gene_freq_3_m <-  matrix_cluster_gene_presence_absence * cluster_freq_3
data_gene_freq_3 <- rep(0, length(data_gene_freq_3_m[,1]))
for (i in 1:length(data_gene_freq_3_m[,1])){
  data_gene_freq_3[i] <- sum(data_gene_freq_3_m[i,1:62])
}

par(mfrow=c(1,3))
plot(data_gene_freq_1 / nrow(subset(clusters,clusters$seqYear==2001)), data_gene_freq_2 / nrow(subset(clusters,clusters$seqYear==2004)))
plot(data_gene_freq_1 / nrow(subset(clusters,clusters$seqYear==2001)), data_gene_freq_3 / nrow(subset(clusters,clusters$seqYear==2007)))
plot(data_gene_freq_2 / nrow(subset(clusters,clusters$seqYear==2004)), data_gene_freq_3 / nrow(subset(clusters,clusters$seqYear==2007)))
# very strong correlation between gene frequencies before and after vaccination
# especially second plot looks a lot like figure 2 d, the first, in Corander et al. (though they only did pre vs. post vacc)
```

```{r}
# correlation of clusters
par(mfrow=c(1,3))
plot(cluster_freq_1 / sum(cluster_freq_1), cluster_freq_2 / sum(cluster_freq_2))
plot(cluster_freq_1 / sum(cluster_freq_1), cluster_freq_3 / sum(cluster_freq_3))
plot(cluster_freq_2 / sum(cluster_freq_2), cluster_freq_3 / sum(cluster_freq_3))
# the second plot (2001 vs. 2007) looks a lot like figure 2 c, the first, in Corander et al.
```

```{r}
# read in information on vaccine types
#library(readxl)
vaccine_types <- read_excel("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/Corander_suppData3.xlsx")
vaccine_types <- vaccine_types[,c(2,3,4,6)]
vaccine_types_mass <- subset(vaccine_types, vaccine_types$Population == "Massachusetts")
isVT <- c()
for (i in 1:nrow(vaccine_types_mass)){
  isVT[vaccine_types_mass$`Accession Code`[i]] <- if (vaccine_types_mass$`Vaccine Type`[i] == "VT") {0} else {1}
}
# I want to create a simple vector instead of a dictionary because this will be easier to use when modelling
# and I also want a consensus for the clusters...
isVT_vec <- rep(0, no_clusters)
for (i in 1:no_clusters){
  curr_cluster <- subset(clusters, clusters$Cluster == i)[,1] # select all genomes in cluster i
  curr_vacc <- accNoToFilename[curr_cluster]
  isVT_vec[i] <- median(isVT[curr_vacc])
  #print(mean(isVT[curr_vacc])) #calculate mean as check for consensus
}
```

```{r}
# make a grouped bar plot similar to Croucher et al.
library(ggplot2)

cluster_names <- rep(1:no_clusters, 3)
cluster_names <- sort(cluster_names)
#cluster_names <- as.character(cluster_names)
seqTimes <- rep(c("2001", "2004", "2007"), no_clusters)
cluster_freq_all_times <- rep(0, no_clusters *3)
for (i in 1:no_clusters) {
  cluster_freq_all_times[3*(i-1) + 1 ] <- cluster_freq_1[i]/sum(cluster_freq_1)
  cluster_freq_all_times[3 * (i-1) + 2] <- cluster_freq_2[i]/sum(cluster_freq_2)
  cluster_freq_all_times[3 * (i-1) + 3] <- cluster_freq_3[i]/sum(cluster_freq_3)
}
cluster_freq_df <- data.frame(cluster_names, seqTimes, cluster_freq_all_times)

ggplot(cluster_freq_df, aes(fill=seqTimes, y=cluster_freq_all_times, x=cluster_names)) +   geom_bar(position="dodge", stat="identity") +
scale_fill_manual("legend", values = c("2001" = "#E69F00", "2004" = "#56B4E9", "2007" = "#009E73")) +
scale_x_continuous(breaks = 1:no_clusters)
```

```{r}
# add low and high levels of selection to the model.

# first, calculate pre/peri and post vacc frequencies of genes:
pre_peri_vacc_gene_freq <- (data_gene_freq_1 + data_gene_freq_2)/(nrow(subset(clusters,clusters$seqYear==2001))+nrow(subset(clusters,clusters$seqYear==2004)))
post_vacc_gene_freq <- data_gene_freq_3 / nrow(subset(clusters,clusters$seqYear==2007))

# calculate delta statistic (refer to Corander et al. for more info)
delta_data <- (post_vacc_gene_freq - pre_peri_vacc_gene_freq) ^ 2 / (1 - pre_peri_vacc_gene_freq * (1 - pre_peri_vacc_gene_freq))
delta_ranking <- rank(delta_data)
#<- sort(delta_data, index.return = TRUE)
# access the indexes of the corresponding genes through sorted_delta$ix, access the values through sorted_delta$x

```



######################################################
### Define model parameters according to the datasets
```{r}
params_n_vP <- list(dt = 1/36, species_no = no_clusters,  gene_no = nrow(cluster_gene_presence_absence), Pop_ini = cluster_freq_1, Pop_eq = cluster_freq_1, capacity = sum(cluster_freq_1), Genotypes = matrix_cluster_gene_presence_absence, sigma_f = 0.14, sigma_w = 0.002, prop_f = 0.25, delta = delta_ranking, m = 0.03, vaccTypes = isVT_vec, v = 0.07, vacc_time = 100) 
```


### Running the model:
```{r}
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)
```

# initial state: 
```{r}
WFmodel_nG_h_vP$state()
```


# running the model for 10, 20, 30 time steps:
```{r}
#WFmodel_nG_h_vP$run(1)
#WFmodel_nG_h_vP$run(2)
#WFmodel_nG_h_vP$run(3)
```



```{r fig.height=5, fig.width=7}
par(mfrow=c(1,1))
dt <- 1
n_particles <- 10L
#WFmodel_nG_h_vP$update_state(pars = params_n_vP, time = 0)
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)


n_times <- 180
x <- array(NA, dim = c(WFmodel_nG_h_vP$info()$len, n_particles, n_times))

for (t in seq_len(n_times)) {
  x[ , , t] <- WFmodel_nG_h_vP$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]



par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
if (length(x[,1,1]) <= 8){
  cols <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7") #8 colorblind friendly colors
} else {
  cols <- rainbow(length(x[,1,1]))
}


library(dplyr)
library(zoo)

matplot(time, rollmean(x[1,1 , ], k=30, fill=NA), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
  matlines(time, rollmean(x[species,1 , ], k=30, fill=NA), col = cols[species], lty = 1)
}
# or 
# matplot(time,(x[1,1 , ]), type = "l",
#         xlab = "Time", ylab = "Number of individuals",
#         col = cols[1], lty = 1, ylim = range(x))
#for (species in 2:length(x[,1,1])) {
#  matlines(time, (x[species,1 , ]), col = cols[species], lty = 1)
#}
#if you want to see all single values, not the monthly rolling mean


legend("bottomright", lwd = 1, col = cols[1:length(x[,1,1])], legend = 1:length(x[,1,1]), bty = "n")
```


```{r}
# create plot colored by whether clusters are vaccine types or not

par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
cols <- rep("#000000", length(x[,1,1]))
for (i in 1:length(cols)){
  cols[i] <- if(isVT_vec[i]==1){"#E69F00"} else {"#000000"}
}


# probably should find a more dynamic way for models with >8 species?
matplot(time, rollmean(x[1,1 , ], k=30, fill=NA), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
  matlines(time, rollmean(x[species,1 , ], k=30, fill=NA), col = cols[species], lty = 1)
}

# or 
# matplot(time,(x[1,1 , ]), type = "l",
#         xlab = "Time", ylab = "Number of individuals",
#         col = cols[1], lty = 1, ylim = range(x))
#for (species in 2:length(x[,1,1])) {
#  matlines(time, (x[species,1 , ]), col = cols[species], lty = 1)
#}
#if you want to see all single values, not the monthly rolling mean


legend("topright", lwd = 1, col = c("#000000","#E69F00"), legend = c("Vaccine Types", "Non-Vaccine Types"), bty = "n")

# vaccine types seem to be less successful, yeah!
```

```{r}
# make a grouped bar plot similar to Croucher et al.
library(ggplot2)

cluster_names <- rep(1:no_clusters, 3)
cluster_names <- sort(cluster_names)
#cluster_names <- as.character(cluster_names)
simTimes <- rep(c("pt 1", "pt 2", "pt 3"), no_clusters)
sim_cluster_freq_all_times <- rep(0, no_clusters *3)
for (i in 1:no_clusters) {
  sim_cluster_freq_all_times[3*(i-1) + 1 ] <- x[i,1,1]/sum(x[,1,1])
  sim_cluster_freq_all_times[3 * (i-1) + 2] <- x[i,1,n_times/2]/sum(x[,1,n_times/2])
  sim_cluster_freq_all_times[3 * (i-1) + 3] <- x[i,1,n_times]/sum(x[,1,n_times])
}
sim_cluster_freq_df <- data.frame(cluster_names, simTimes, sim_cluster_freq_all_times)


library(gridExtra)


sim_plot <- ggplot(sim_cluster_freq_df, aes(fill=simTimes, y=sim_cluster_freq_all_times, x=cluster_names)) +   geom_bar(position="dodge", stat="identity") +
scale_fill_manual("legend", values = c("pt 1" = "#E69F00", "pt 2" = "#56B4E9", "pt 3" = "#009E73")) +
scale_x_continuous(breaks = 1:no_clusters)

data_plot <- ggplot(cluster_freq_df, aes(fill=seqTimes, y=cluster_freq_all_times, x=cluster_names)) +   geom_bar(position="dodge", stat="identity") +
scale_fill_manual("legend", values = c("2001" = "#E69F00", "2004" = "#56B4E9", "2007" = "#009E73")) +
scale_x_continuous(breaks = 1:no_clusters)

grid.arrange(data_plot, sim_plot, nrow = 2)
# this is obviously not great at the moment. However, this is no surprise because the model parameters were not fitted against the data yet.

# this can be used to compare the simulated data to the real data
# 2001 should be the same because this is a deterministic start state
# the other times n_times/2 and n_times are chosen quite arbitrarily at the moment. not sure how to choose them?
```


### now, the fitting can begin! :-)
```{r}
#install.packages("drat") # -- if you don't have drat installed
drat:::add("ncov-ic")
#install.packages("mcstate")
library(mcstate)
```

```{r}
# process data with particle filter:
dt <- 1/36 # we assume that the generation time of Strep. pneumo is 1 month
# we have data from 2001, 2004, 2007, so we want 3 (years) * 12 (months) = 36 updates in-between
mass_data <- mcstate::particle_filter_data(data = fitting_cluster_freq_df,
                                          time = "year",
                                          rate = 1 / dt,
                                          initial_time = 2001)
```

```{r}
# Defining the comparison function
# state is the model state at some point in time
# observed is the real data 
cluster_compare <- function(state, observed, pars = NULL) {
  exp_noise <- 1e6
  #print(dim(state))
  
  #state_x[ , ] <- state
  state <- state[-1, ]
  clusters_modelled <- state[,1]
  clusters_observed <- observed$"1"
  lambda <- clusters_modelled +
    rexp(n = length(clusters_modelled), rate = exp_noise)
  dpois(x = clusters_observed, lambda = lambda, log = TRUE)
}
```

```{r}
### Inferring parameters

n_particles <- 10
### I have an issue with the dimensions!
# these three blocks of code only run if n_particles = 62.
# so probably it confuses the number of strains and the number of particles.
# that is a bit weird, I think.
# maybe in my data, it think that the three times points are the three compartments?
# but that does not really make sense - it recognizes 2001, 2004 and 2007 as times.
# BUT the info about the different strains got lost - it is not in the dataset.
# SO that is because for the SIR they only had the data for one compartment, the I, here I have infos about all compartments.
filter <- mcstate::particle_filter$new(data = mass_data,
                                       model = WF_nG_h_vP,
                                       n_particles = n_particles,
                                       compare = cluster_compare,
                                       seed = 1L)
```

```{r}
filter$run(save_history = TRUE, pars = params_n_vP)
# this results in the following error message at the moment:
# Error: Expected a vector of length 10 for 'index' but given 62

# I seem to have a problem with the dimensions still.
# maybe I should try fitting it in just one dimension but that does not sound very promising...
# probably, I should go back to my toy example with 4 species, try to construct a data set and then try to fit it.
# in that setting, the mistake will probably be easier to spot. :-) 
```

```{r}
# plot particle filter

plot_particle_filter <- function(history, true_history, times, obs_end = NULL) {
  if (is.null(obs_end)) {
    obs_end <- max(times)
  }

  par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
  cols <- c(S = "#8c8cd9", I = "#cc0044", R = "#999966")
  matplot(times, t(history[1, , -1]), type = "l",
          xlab = "Time", ylab = "Number of individuals",
          col = cols[["S"]], lty = 1, ylim = range(history))
  matlines(times, t(history[2, , -1]), col = cols[["I"]], lty = 1)
  matlines(times, t(history[3, , -1]), col = cols[["R"]], lty = 1)
  matpoints(times[1:obs_end], t(true_history[1:3, , -1]), pch = 19,
            col = cols)
  legend("left", lwd = 1, col = cols, legend = names(cols), bty = "n")
}

true_history <- cluster_freq_df$cluster_freq_all_times
plot_particle_filter(filter$history(), true_history, 1:180)
```

