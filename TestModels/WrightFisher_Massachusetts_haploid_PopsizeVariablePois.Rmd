---
title: "Wright Fisher Model for Massachusetts dataset"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sir_models}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: inline
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
lang_output <- function(x, lang) {
  cat(c(sprintf("```%s", lang), x, "```"), sep = "\n")
}
cc_output <- function(x) lang_output(x, "cc")
r_output <- function(x) lang_output(x, "r")
plain_output <- function(x) lang_output(x, "plain")
```

# Stochastic Lotka Volterra model definition


$$\begin{align*}
\frac{dR}{dt} &= \alpha R -\beta RC \\
\frac{dC}{dt} &= \delta \beta RC - \gamma C \\
\end{align*}$$

$R$ is the number of prey, $C$ is the number of predators.$\alpha$ is the birth rate of the prey, $\beta$ is the kill rate, $\gamma$ is the death rate of the predators and $\delta$ describes how much a predator benefits from killing prey.

Discretising this model in time steps of width $dt$ gives the following update equations for each time step:

$$\begin{align*}
R_{t+1} &= R_t - n_{RC} + n_R \\
C_{t+1} &= C_t + \delta n_{RC}  - n_C
\end{align*}$$

where
$$\begin{align*}
n_{R} &\sim B(R, 1 - e^{-\alpha \cdot dt}) \\
n_{RC} &\sim B(R, 1 - e^{-\beta C \cdot dt}) \\
n_{C} &\sim B(C, 1 - e^{-\gamma \cdot dt})
\end{align*}$$

## Implementing the SIR model using [`odin.dust`](https://mrc-ide.github.io/odin.dust/)

The above equations can straightforwardly be written out using the odin DSL:

```{r odin_sir, echo = FALSE, results = "asis"}
r_output(readLines(file.path("WrightFisher_nGenotypes_haploid_PopsizeVariablePois.R")))
```

This is converted to a C++ dust model, and compiled into a library in a single step, using [`odin.dust`](https://mrc-ide.github.io/odin.dust/). Save the above code as a file named `sir.R`. File names must not contain special characters.

```{r}
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
```

```{r}
WF_nG_h_vP <- odin.dust::odin_dust("WrightFisher_nGenotypes_haploid_PopsizeVariablePois.R")
```

### READING IN DATA
### 1) Cluster information from PopPUNK
### 2) Gene presence absence matrix from ggCaller

```{r}
# reading in the cluster produced by PopPUNK
clusters <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/refined_modelfitk3_clusters.csv")
no_clusters <- max(clusters[,2]) # number of clusters in dataset
```

```{r}
# reading in the gene presence absence matrix produced by ggCaller
gene_presence_absence <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/gene_presence_absence.csv", header=FALSE)

# converting the gene presence absence matrix into a boolean df (0 = gene not present, 1 = gene present)
convert_to_bool <- function(x){
  if (x=="") 0 else 1
}
bool_gene_presence_absence <- gene_presence_absence

for (i in 4:length(bool_gene_presence_absence[1,])) {
  bool_gene_presence_absence[,i] <- unlist(lapply(bool_gene_presence_absence[,i], FUN =  convert_to_bool))
}
bool_gene_presence_absence[1,] <- gene_presence_absence[1,]
```

```{r}
# calculate frequency of genes to only keep those which appear in 5-95% of the genomes
gene_freq <- rep(0, nrow(bool_gene_presence_absence)-1)
for (i in 1:length(gene_freq)) {
  gene_freq[i] <- sum(as.integer(bool_gene_presence_absence[i+1,4:ncol(bool_gene_presence_absence)]))
}
gene_freq <- gene_freq / (length(bool_gene_presence_absence[2,])-3)

# create a dataframe that only contains the genes that appear in 5-95% of the genomes
filtered_bool_gene_presence_absence <- data.frame(matrix(nrow = 0, ncol = length(bool_gene_presence_absence[1,])))

for (i in 1:length(gene_freq)){
  if (0.05 < gene_freq[i] & gene_freq[i] < 0.95 ){
    filtered_bool_gene_presence_absence[nrow(filtered_bool_gene_presence_absence)+1,] <- bool_gene_presence_absence[i+1,]
  }
}
colnames(filtered_bool_gene_presence_absence) <- bool_gene_presence_absence[1,]
```

```{r}
### make consensus genome for clusters
# attempt 1: always let majority decide (if more than 50% in the cluster don't have gene then 0, else 1)
# should be easy to do with median

cluster_gene_presence_absence <- data.frame(matrix(nrow = nrow(filtered_bool_gene_presence_absence), ncol = no_clusters+3))
colnames(cluster_gene_presence_absence)[1:3] <- colnames(filtered_bool_gene_presence_absence)[1:3]
cluster_gene_presence_absence[1:3] <- filtered_bool_gene_presence_absence[1:3]
colnames(cluster_gene_presence_absence)[4:ncol(cluster_gene_presence_absence)] <- 1:no_clusters
for (i in 1:no_clusters){
  curr_cluster <- subset(clusters, clusters$Cluster == i)[,1] # select all genomes in cluster i
  curr_genomes <- as.matrix(filtered_bool_gene_presence_absence[,curr_cluster])
  for (j in 1:nrow(filtered_bool_gene_presence_absence)){
    cluster_gene_presence_absence[j,i+3] <- as.double(median(as.integer(curr_genomes[j,])))
  }
}
matrix_cluster_gene_presence_absence <- as.matrix((cluster_gene_presence_absence[,4:ncol(cluster_gene_presence_absence)]))

# attempt 2: record relative frequencies. Probably not advantageous.
# attempt 3: keep track of all existing variants. This can be done later
```

```{r}
#calculate the frequency of the gene clusters
cluster_freq <- rep(0,no_clusters)
for (i in 1:no_clusters){
  cluster_freq[i] <- length(subset(clusters, clusters$Cluster == i)[,1])
}
#cluster_freq <- cluster_freq / length(clusters[,1])
# I think I don't want frequency but rather the absolute numbers?
```


### Define model parameters according to the datasets
```{r}
params_n_vP <- list(dt = 1, species_no = no_clusters,  gene_no = nrow(cluster_gene_presence_absence), Pop_ini = cluster_freq, Pop_eq = cluster_freq, capacity = 1000, Genotypes = matrix_cluster_gene_presence_absence, sigma = 0.02, m = 0.00, vaccTypes = rep(0, no_clusters), v = 0, vacc_time = 100) 
```


### Running the model:
```{r}
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)
```

# initial state: 
```{r}
WFmodel_nG_h_vP$state()
```


# running the model for 10, 20, 30 time steps:
```{r}
WFmodel_nG_h_vP$run(1)
WFmodel_nG_h_vP$run(2)
WFmodel_nG_h_vP$run(3)
```



```{r fig.height=5, fig.width=7}
dt <- 1
n_particles <- 10L
#WFmodel_nG_h_vP$update_state(pars = params_n_vP, time = 0)
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)


n_times <- 1000
x <- array(NA, dim = c(WFmodel_nG_h_vP$info()$len, n_particles, n_times))

for (t in seq_len(n_times)) {
  x[ , , t] <- WFmodel_nG_h_vP$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]

par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
if (length(x[,1,1]) <= 8){
  cols <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7") #8 colorblind friendly colors
} else {
  cols <- rainbow(length(x[,1,1]))
}

# probably should find a more dynamic way for models with >8 species?
matplot(time, (x[1,1 , ]), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
  matlines(time, (x[species,1 , ]), col = cols[species], lty = 1)
}



legend("bottomright", lwd = 1, col = cols[1:length(x[,1,1])], legend = 1:length(x[,1,1]), bty = "n")
```

```{r fig.height=5, fig.width=7}
matplot(time, t(x[1, , ]), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
  matlines(time, t(x[species,, ]), col = cols[species], lty = 1)
}
#matlines(time, t(x[species,, ]), col = cols[species], lty = 1)

legend("right", lwd = 1, col = cols,  legend = 1:length(x[,1,1]), bty = "n")
```

```{r fig.height=5, fig.width=7}
dt <- 1
n_particles <- 10L
#WFmodel_nG_h_vP$update_state(pars = params_n_vP, time = 0)
WFmodel_nG_h_vP <- WF_nG_h_vP$new(pars = params_n_vP,
                         time = 1,
                         n_particles = 10L,
                         n_threads = 4L,
                         seed = 1L)


n_times <- 10000
x <- array(NA, dim = c(WFmodel_nG_h_vP$info()$len, n_particles, n_times))

for (t in seq_len(n_times)) {
  x[ , , t] <- WFmodel_nG_h_vP$run(t)
}
time <- x[1, 1, ]
x <- x[-1, , ]

par(mar = c(4.1, 5.1, 0.5, 0.5), las = 1)
if (length(x[,1,1]) <= 8){
  cols <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7") #8 colorblind friendly colors
} else {
  cols <- rainbow(length(x[,1,1]))
}

# probably should find a more dynamic way for models with >8 species?
matplot(time, (x[1,2 , ]), type = "l",
         xlab = "Time", ylab = "Number of individuals",
         col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,2,1])) {
  matlines(time, (x[species,2 , ]), col = cols[species], lty = 1)
}



legend("right", lwd = 1, col = cols[1:length(x[,2,1])], legend = 1:length(x[,2,1]), bty = "n")
```



