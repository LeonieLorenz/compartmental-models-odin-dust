xlab = "Time", ylab = "Number of individuals",
col = cols[1], lty = 1, ylim = range(x))
for (species in 2:length(x[,1,1])) {
matlines(time, (x[species,1 , ]), col = cols[species], lty = 1)
}
legend("bottomright", lwd = 1, col = cols[1:length(x[,1,1])], legend = 1:length(x[,1,1]), bty = "n")
tail(x)
tail(x[,,17])
(x[,,17])
(x[,,100])
(x[,,1000])
matrix_cluster_gene_presence_absence * x[,1,1]
x[,1,1]
nrows(matrix_cluster_gene_presence_absence)
dim(matrix_cluster_gene_presence_absence)
matrix_cluster_gene_presence_absence * t(x[,1,1])
matrix_cluster_gene_presence_absence[1,] * (x[,1,1])
matrix_cluster_gene_presence_absence[1,]
matrix_cluster_gene_presence_absence[1,] * (x[,1,1])
matrix_cluster_gene_presence_absence * (x[,1,1])
matrix_cluster_gene_presence_absence %*% (x[,1,1])
y <- matrix_cluster_gene_presence_absence %*% (x[,1,])
matplot(time, (y[1,1 , ]), type = "l",
xlab = "Time", ylab = "Number of individuals",
col = cols[1], lty = 1, ylim = range(y))
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
make_transform(Pop_ini)
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- mcstate::pmcmc_parameter("species_no", 4, min = 4, max = 4)
gene_no <- mcstate::pmcmc_parameter("gene_no", 5, min = 5, max = 5)
Pop_ini <- make_transform(pre_vacc_pop)
Pop_eq <- make_transform(pre_vacc_pop)
capacity <- make_transform(sum(pre_vacc_pop))
Genotypes <- make_transform(genotype_matr)
delta <- make_transform(delta_rank)
vaccTypes <- make_transform(is_vaccType)
vacc_time <- mcstate::pmcmc_parameter("vacc_time", 5, min = 5, max = 5)
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 14) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, capacity = capacity, Genotypes = Genotypes, delta = delta, vaccTypes = vaccTypes, vacc_time = vacc_time),
proposal_matrix)
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- mcstate::pmcmc_parameter("species_no", 4, min = 4, max = 4)
gene_no <- mcstate::pmcmc_parameter("gene_no", 5, min = 5, max = 5)
Pop_ini <- make_transform(pre_vacc_pop)
Pop_eq <- make_transform(pre_vacc_pop)
capacity <- make_transform(sum(pre_vacc_pop))
Genotypes <- make_transform(genotype_matr)
delta <- make_transform(delta_rank)
vaccTypes <- make_transform(is_vaccType)
vacc_time <- mcstate::pmcmc_parameter("vacc_time", 5, min = 5, max = 5)
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 14) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, Pop_ini = Pop_ini, Pop_eq = Pop_eq, capacity = capacity, Genotypes = Genotypes, delta = delta, vaccTypes = vaccTypes, vacc_time = vacc_time),proposal_matrix, transform = make_transform)
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- mcstate::pmcmc_parameter("species_no", 4, min = 4, max = 4)
gene_no <- mcstate::pmcmc_parameter("gene_no", 5, min = 5, max = 5)
#Pop_ini <- make_transform(pre_vacc_pop)
#Pop_eq <- make_transform(pre_vacc_pop)
#Genotypes <- make_transform(genotype_matr)
##capacity <- make_transform(sum(pre_vacc_pop))
#delta <- make_transform(delta_rank)
#vaccTypes <- make_transform(is_vaccType)
vacc_time <- mcstate::pmcmc_parameter("vacc_time", 5, min = 5, max = 5)
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 14) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, vacc_time = vacc_time), proposal_matrix, transform = list(make_transform(pre_vacc_pop),make_transform(pre_vacc_pop), make_transform(genotype_matr),ake_transform(sum(pre_vacc_pop), make_transform(capacity), make_transform(delta_rank), make_transform(is_vaccType))))
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- mcstate::pmcmc_parameter("species_no", 4, min = 4, max = 4)
gene_no <- mcstate::pmcmc_parameter("gene_no", 5, min = 5, max = 5)
#Pop_ini <- make_transform(pre_vacc_pop)
#Pop_eq <- make_transform(pre_vacc_pop)
#Genotypes <- make_transform(genotype_matr)
##capacity <- make_transform(sum(pre_vacc_pop))
#delta <- make_transform(delta_rank)
#vaccTypes <- make_transform(is_vaccType)
vacc_time <- mcstate::pmcmc_parameter("vacc_time", 5, min = 5, max = 5)
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 14) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, vacc_time = vacc_time), proposal_matrix, transform = list(make_transform(pre_vacc_pop),make_transform(pre_vacc_pop), make_transform(genotype_matr), make_transform(sum(pre_vacc_pop), make_transform(capacity), make_transform(delta_rank), make_transform(is_vaccType))))
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- mcstate::pmcmc_parameter("species_no", 4, min = 4, max = 4)
gene_no <- mcstate::pmcmc_parameter("gene_no", 5, min = 5, max = 5)
#Pop_ini <- make_transform(pre_vacc_pop)
#Pop_eq <- make_transform(pre_vacc_pop)
#Genotypes <- make_transform(genotype_matr)
##capacity <- make_transform(sum(pre_vacc_pop))
#delta <- make_transform(delta_rank)
#vaccTypes <- make_transform(is_vaccType)
vacc_time <- mcstate::pmcmc_parameter("vacc_time", 5, min = 5, max = 5)
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 14) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, vacc_time = vacc_time), proposal_matrix, transform = make_transform(c(pre_vacc_pop, pre_vacc_pop, genotype_matr, sum(pre_vacc_pop, capacity, delta_rank, is_vaccType))))
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- mcstate::pmcmc_parameter("species_no", 4, min = 4, max = 4)
gene_no <- mcstate::pmcmc_parameter("gene_no", 5, min = 5, max = 5)
#Pop_ini <- make_transform(pre_vacc_pop)
#Pop_eq <- make_transform(pre_vacc_pop)
#Genotypes <- make_transform(genotype_matr)
##capacity <- make_transform(sum(pre_vacc_pop))
#delta <- make_transform(delta_rank)
#vaccTypes <- make_transform(is_vaccType)
vacc_time <- mcstate::pmcmc_parameter("vacc_time", 5, min = 5, max = 5)
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 8) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, vacc_time = vacc_time), proposal_matrix, transform = make_transform(c(pre_vacc_pop, pre_vacc_pop, genotype_matr, sum(pre_vacc_pop, capacity, delta_rank, is_vaccType))))
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
filter
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
Pop_eq
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = rep(100,4), Pop_eq = c(400, 20, 20, 20), capacity = 400, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,0,1)), GeneFitness = c(0.02, 0, 0, 0.01, 0.03))
# the following parameters work reliably to produce the expected behaviour:
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = c(150,350,350,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02, m = 0.002)
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = c(150,350,350,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02, m = 0.00, vaccTypes = c(0,0,1,0), v = 0.002, vacc_time = 100)
# the following parameters create the setting where two strains survive and two die!
#params_n_vP <- list(dt = 1/36, species_no = 4,  gene_no = 5, Pop_ini = c(150,350,350,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02, m = 0.00, vaccTypes = c(0,0,1,0), v = 0, vacc_time = 100)
params_n_vP <- list(dt = 1/36, species_no = 4,  gene_no = 5, Pop_ini = pre_vacc_pop, Pop_eq = pre_vacc_pop, capacity = sum(pre_vacc_pop), Genotypes = genotype_matr, sigma_f = 0.14, sigma_w = 0.002, prop_f = 0.25, delta = delta_rank, m = 0.03, vaccTypes = is_vaccType, v = 0.07, vacc_time = 5)
# add low and high levels of selection to the model.
# first, calculate pre/peri and post vacc frequencies of genes:
pre_vacc_pop <- c(100,300,300,100)
genotype_matr <- cbind(c(1,1,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1))
pre_vacc_freq <- c(4/8, 1/8, 3/8, 4/8, 4/8) # calculated that manually from pre_vacc_pop and genotype_matr
post_vacc_freq <- c(3/8, 1/8, 4/8, 4/8, 4/8) # just an example
is_vaccType <- c(0,0,1,0)
# calculate delta statistic (refer to Corander et al. for more info)
delta_ex <- (post_vacc_freq - pre_vacc_freq) ^ 2 / (1 - pre_vacc_freq * (1 - pre_vacc_freq))
delta_rank <- rank(delta_ex)
#<- sort(delta_data, index.return = TRUE)
# access the indexes of the corresponding genes through sorted_delta$ix, access the values through sorted_delta$x
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = rep(100,4), Pop_eq = c(400, 20, 20, 20), capacity = 400, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,0,1)), GeneFitness = c(0.02, 0, 0, 0.01, 0.03))
# the following parameters work reliably to produce the expected behaviour:
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = c(150,350,350,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02, m = 0.002)
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = c(150,350,350,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02, m = 0.00, vaccTypes = c(0,0,1,0), v = 0.002, vacc_time = 100)
# the following parameters create the setting where two strains survive and two die!
#params_n_vP <- list(dt = 1/36, species_no = 4,  gene_no = 5, Pop_ini = c(150,350,350,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02, m = 0.00, vaccTypes = c(0,0,1,0), v = 0, vacc_time = 100)
params_n_vP <- list(dt = 1/36, species_no = 4,  gene_no = 5, Pop_ini = pre_vacc_pop, Pop_eq = pre_vacc_pop, capacity = sum(pre_vacc_pop), Genotypes = genotype_matr, sigma_f = 0.14, sigma_w = 0.002, prop_f = 0.25, delta = delta_rank, m = 0.03, vaccTypes = is_vaccType, v = 0.07, vacc_time = 5)
# the following parameters show the expected behaviour in about 50% of the times. Probably stochastic effects because the population sizes of gt 1, 3 and 4 are so small in the beginning?
# params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = c(150,550,250,150), Pop_eq = c(100,400,400,100), capacity = 1000, Genotypes = cbind(c(1,0,0,0,0),c(0,0,1,0,0),c(1,0,0,1,1),c(0,0,0,1,1)), sigma = 0.02)
### maybe I can investigate whether binomial draws are more robust? (later)
#params_n_vP <- list(dt = 1, species_no = 4,  gene_no = 5, Pop_ini = rep(100,4), Pop_eq = c(20, 20, 400, 20), capacity = 300, Genotypes = cbind(c(1,0,0,0,0),c(0,1,0,0,0),c(1,0,0,1,1),c(0,0,0,0,1)), GeneFitness = c(0.1, 0.1, 0.2, 0.1, 0.1))
Pop_eq
Pop_eq <- pre_vacc_pop
Pop_eq
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- 4
gene_no <- 5
Pop_ini <- pre_vacc_pop
Pop_eq <- pre_vacc_pop
Genotypes <-genotype_matr
capacity <- sum(pre_vacc_pop)
delta <- delta_rank
vaccTypes <- is_vaccType
vacc_time <- vacc_time
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v, species_no = species_no,  gene_no = gene_no, vacc_time = vacc_time), proposal_matrix, transform = make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- 4
gene_no <- 5
Pop_ini <- pre_vacc_pop
Pop_eq <- pre_vacc_pop
Genotypes <-genotype_matr
capacity <- sum(pre_vacc_pop)
delta <- delta_rank
vaccTypes <- is_vaccType
vacc_time <- vacc_time
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v), proposal_matrix, transform = make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
pars$initial()
mcmc_pars$initial()
pars$model(mcmc_pars$initial())
mcmc_pars$model(mcmc_pars$initial())
pre_vacc_pop
genotype_matr
vacc_time
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- 4
gene_no <- 5
Pop_ini <- pre_vacc_pop
Pop_eq <- pre_vacc_pop
Genotypes <-genotype_matr
capacity <- sum(pre_vacc_pop)
delta <- delta_rank
vaccTypes <- is_vaccType
vacc_time <- 5
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v), proposal_matrix, transform = make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
vaccTypes
delta
capacity
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
mcmc_pars$model(mcmc_pars$initial())
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- 4
gene_no <- 5
Pop_ini <- pre_vacc_pop
Pop_eq <- pre_vacc_pop
Genotypes <-genotype_matr
capacity <- sum(pre_vacc_pop)
delta <- delta_rank
vaccTypes <- is_vaccType
vacc_time <- 5
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v), proposal_matrix, transform = make_transform(Pop_ini))
#, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
mcmc_pars$model(mcmc_pars$initial())
# read this: https://mrc-ide.github.io/mcstate/reference/pmcmc_parameters.html
# it explains how to not fit all parameters but just the ones I want
# non-scalar parameters have to be transformed for this.
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
# Using MCMC to infer parameters
sigma_f <- mcstate::pmcmc_parameter("sigma_f", 0.15, min = 0)
sigma_w <- mcstate::pmcmc_parameter("sigma_w", 0.05, min = 0)
prop_f <- mcstate::pmcmc_parameter("prop_f", 0.25, min = 0, max = 1)
m <- mcstate::pmcmc_parameter("m", 0.03, min = 0)
v <- mcstate::pmcmc_parameter("v", 0.05, min = 0)
species_no <- 4
gene_no <- 5
Pop_ini <- pre_vacc_pop
Pop_eq <- pre_vacc_pop
Genotypes <-genotype_matr
capacity <- sum(pre_vacc_pop)
delta <- delta_rank
vaccTypes <- is_vaccType
vacc_time <- 5
make_transform <- function(m) {
function(theta) {
c(list(m = m), as.list(theta))
}
}
proposal_matrix <- diag(0.1, 5) # the proposal matrix defines the covariance-variance matrix for a mult normal dist
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v), proposal_matrix, transform = make_transform(c(Pop_iniPop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
mcmc_pars$model(mcmc_pars$initial())
# here, all parameters are proposed independently.
# think about this, this might not actually be true
mcmc_pars <- mcstate::pmcmc_parameters$new(list(sigma_f = sigma_f, sigma_w = sigma_w, prop_f = prop_f, m = m, v = v), proposal_matrix, transform = make_transform(c(Pop_ini, Pop_eq, Genotypes, capacity, delta, vaccTypes, species_no, gene_no, vacc_time)))
mcmc_pars$model(mcmc_pars$initial())
n_steps <- 500
n_burnin <- 200
control <- mcstate::pmcmc_control(
n_steps,
save_state = TRUE,
save_trajectories = TRUE,
progress = TRUE)
pmcmc_run <- mcstate::pmcmc(mcmc_pars, filter, control = control)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
lang_output <- function(x, lang) {
cat(c(sprintf("```%s", lang), x, "```"), sep = "\n")
}
cc_output <- function(x) lang_output(x, "cc")
r_output <- function(x) lang_output(x, "r")
plain_output <- function(x) lang_output(x, "plain")
setwd("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/TestModels")
r_output(readLines(file.path("WrightFisher_nGenotypes_haploid_PopsizeVariablePois.R")))
# install.packages("drat") # -- if you don't have drat installed
# drat:::add("ncov-ic")
# install.packages("odin.dust")
library(odin.dust)
WF_nG_h_vP <- odin.dust::odin_dust("WrightFisher_nGenotypes_haploid_PopsizeVariablePois.R")
# reading in the cluster produced by PopPUNK
clusters <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/refined_modelfitk3_clusters.csv")
no_clusters <- max(clusters[,2]) # number of clusters in dataset
# reading in the gene presence absence matrix produced by ggCaller
gene_presence_absence <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/gene_presence_absence.csv", header=FALSE)
# converting the gene presence absence matrix into a boolean df (0 = gene not present, 1 = gene present)
convert_to_bool <- function(x){
if (x=="") 0 else 1
}
bool_gene_presence_absence <- gene_presence_absence
for (i in 4:length(bool_gene_presence_absence[1,])) {
bool_gene_presence_absence[,i] <- unlist(lapply(bool_gene_presence_absence[,i], FUN =  convert_to_bool))
}
bool_gene_presence_absence[1,] <- gene_presence_absence[1,]
# reading in the cluster produced by PopPUNK
clusters <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/refined_modelfitk3_clusters.csv")
no_clusters <- max(clusters[,2]) # number of clusters in dataset
# reading in the gene presence absence matrix produced by ggCaller
gene_presence_absence <- read.csv("~/Documents/PhD_Project/Code/1st_project/odin-dust-examples/Data/gene_presence_absence.csv", header=FALSE)
# converting the gene presence absence matrix into a boolean df (0 = gene not present, 1 = gene present)
convert_to_bool <- function(x){
if (x=="") 0 else 1
}
bool_gene_presence_absence <- gene_presence_absence
for (i in 4:length(bool_gene_presence_absence[1,])) {
bool_gene_presence_absence[,i] <- unlist(lapply(bool_gene_presence_absence[,i], FUN =  convert_to_bool))
}
bool_gene_presence_absence[1,] <- gene_presence_absence[1,]
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test <- lapply(as.integer(bool_gene_presence_absence[2:nrow(bool_gene_presence_absence),4:ncol(bool_gene_presence_absence)]), sum)
gene_freq_test <- lapply((bool_gene_presence_absence[2:nrow(bool_gene_presence_absence),4:ncol(bool_gene_presence_absence)]), sum(as.integer))
sum_as_int <- function(x){
sum(as.integer(x))
}
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test <- lapply((bool_gene_presence_absence[2:nrow(bool_gene_presence_absence),4:ncol(bool_gene_presence_absence)]), sum_as_int)
gene_freq_test
gene_freq
tail(gene_freq)
gene_freq <- rep(0, nrow(bool_gene_presence_absence)-1)
for (i in 1:length(gene_freq)) {
gene_freq[i] <- sum(as.integer(bool_gene_presence_absence[i+1,4:ncol(bool_gene_presence_absence)]))
}
gene_freq
sum_as_int <- function(x){
sum(as.integer(x))
}
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test <- lapply((bool_gene_presence_absence[2:nrow(bool_gene_presence_absence),4:ncol(bool_gene_presence_absence)]), sum_as_int)
gene_freq_test
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test <- lapply((bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]), sum_as_int)
warnings()
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test[] <- lapply((bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]), sum_as_int)
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test[] <- sapply((bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]), sum_as_int)
head(bool_gene_presence_absence)
gf_bool_gene_presence_absence <- bool_gene_presence_absence[2:nrow(bool_gene_presence_absence),]
gf_bool_gene_presence_absence
gene_freq_test[] <- sapply((gf_bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]), sum_as_int)
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test[] <- sapply((gf_bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]), sum_as_int)
sum_as_int <- function(x){
sum(as.integer(x))
print(length(x))
}
gene_freq_test <- rep(0, nrow(bool_gene_presence_absence)-1)
gene_freq_test[] <- sapply((gf_bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]), sum_as_int)
length(gene_freq_test)
length(gf_bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence))
length(gf_bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)])
sum(as.integer(gf_bool_gene_presence_absence[,4:ncol(bool_gene_presence_absence)]))
sum(as.integer(gf_bool_gene_presence_absence[1,4:ncol(bool_gene_presence_absence)]))
sum(as.integer(gf_bool_gene_presence_absence[2,4:ncol(bool_gene_presence_absence)]))
